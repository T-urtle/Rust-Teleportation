//tp mods
//Reference: UnityEngine.UI
using System.Collections.Generic;
using Newtonsoft.Json;
using UnityEngine;
using System.Linq;
using Oxide.Core;
using System;

namespace Oxide.Plugins
{
    using HomeData = Dictionary<ulong, Dictionary<string, Vector3>>;
    using WarpData = Dictionary<string, Vector3>;
    using LastUsageDictionary = Dictionary<ulong, DateTime>;

    [Info("HW Teleportation", "LaserHydra", "1.6.1")]
    [Description("Implements different teleportation features such as warps & homes")]
    internal class HWTeleportation : HurtworldPlugin
    {
        #region Fields

        private const string LocationWildcard = "~";

        private Configuration _config;

        private HomeData _homes = new HomeData();
        private WarpData _warps = new WarpData();

        private Dictionary<PlayerSession, PlayerSession> _pendingRequests = new Dictionary<PlayerSession, PlayerSession>();
        private Dictionary<PlayerSession, Timer> _pendingTimers = new Dictionary<PlayerSession, Timer>();

        private LastUsageDictionary _lastTpr = new LastUsageDictionary();
        private LastUsageDictionary _lastHome = new LastUsageDictionary();
        private LastUsageDictionary _lastWarp = new LastUsageDictionary();

        #endregion

        #region Hooks

        private void Loaded()
        {
            permission.RegisterPermission($"{this.Name}.admin", this);
            permission.RegisterPermission($"{this.Name}.tpr", this);
            permission.RegisterPermission($"{this.Name}.home", this);
            permission.RegisterPermission($"{this.Name}.warp", this);

            LoadConfig();
            LoadData();

            foreach (var kvp in _config.Home.HomeLimitPermissions)
                permission.RegisterPermission(kvp.Key, this);
        }

        #endregion

        #region Home & Warp Data

        private void LoadData()
        {
            _homes = Interface.Oxide.DataFileSystem.ReadObject<HomeData>("Teleportation/Homes");
            _warps = Interface.Oxide.DataFileSystem.ReadObject<WarpData>("Teleportation/Warps");
        }

        private void SaveData()
        {
            Interface.GetMod().DataFileSystem.WriteObject("Teleportation/Homes", _homes);
            Interface.GetMod().DataFileSystem.WriteObject("Teleportation/Warps", _warps);
        }

        #endregion

        #region Admin Teleportation

        [ChatCommand("tp")]
        private void CmdTeleport(PlayerSession player, string command, string[] args)
        {
            if (!HasPerm(player, "admin"))
            {
                SendChatMessage(player, GetMessage("No Permission", player));
                return;
            }

            switch (args.Length)
            {
                case 1:

                    PlayerSession target = GetPlayer(args[0], player);

                    if (target == null)
                        return;

                    if(!IsSafePlayer(target))
                    {
                        SendChatMessage(player, GetMessage("Target Location Unsafe", player));
                        return;
                    }

                    TeleportToPlayer(player, target);
                    SendChatMessage(player, GetMessage("Teleported", player).Replace("{target}", target.Identity.Name));

                    break;

                case 2:

                    PlayerSession teleportPlayer = GetPlayer(args[0], player);
                    PlayerSession targetPlayer = GetPlayer(args[1], player);

                    if (targetPlayer == null || teleportPlayer == null)
                        return;

                    if(!IsSafePlayer(targetPlayer))
                    {
                        SendChatMessage(player, GetMessage("Target Location Unsafe", player));
                        return;
                    }

                    TeleportToPlayer(teleportPlayer, targetPlayer);
                    SendChatMessage(teleportPlayer, GetMessage("Teleported", teleportPlayer).Replace("{target}", targetPlayer.Identity.Name));

                    break;

                case 3:

                    float x = args[0] == LocationWildcard
                        ? player.WorldPlayerEntity.transform.position.x 
                        : Convert.ToSingle(args[0]);

                    float y = args[1] == LocationWildcard
                        ? player.WorldPlayerEntity.transform.position.y
                        : Convert.ToSingle(args[1]);

                    float z = args[2] == LocationWildcard
                        ? player.WorldPlayerEntity.transform.position.z
                        : Convert.ToSingle(args[2]);

                    if (!IsSafeLocation(new Vector3(x,y,z)))
                    {
                        SendChatMessage(player, GetMessage("Target Location Unsafe", player));
                        return;
                    }

                    TeleportToLocation(player, new Vector3(x, y, z));
                    SendChatMessage(player, GetMessage("Teleported", player).Replace("{target}", $"(X: {x}, Y: {y}, Z: {z})."));

                    break;

                default:

                    SendChatMessage(player, "/tp {target}\n/tp {player} {target}\n/tp {x} {y} {z}");

                    break;
            }
        }

        [ChatCommand("tphere")]
        private void CmdTeleportHere(PlayerSession player, string command, string[] args)
        {
            if (!HasPerm(player, "admin"))
            {
                SendChatMessage(player, GetMessage("No Permission", player));
                return;
            }

            if (args.Length != 1)
            {
                SendChatMessage(player, "Syntax: /tphere {player}");
                return;
            }

            PlayerSession target = GetPlayer(args[0], player);

            if (target == null)
                return;

            if (target == player)
            {
                SendChatMessage(player, GetMessage("Teleport To Self", player));
                return;
            }

            TeleportToPlayer(target, player);

            SendChatMessage(target, 
                GetMessage("Teleported", target)
                    .Replace("{target}", player.Identity.Name)
            );
        }

        #endregion

        #region Homes

        [ChatCommand("removehome")]
        private void CmdRemoveHome(PlayerSession player, string command, string[] args)
        {
            if (!HasPerm(player, "home"))
            {
                SendChatMessage(player, GetMessage("No Permission", player));
                return;
            }

            if (!_config.Home.Enabled)
                return;

            if (args.Length != 1)
            {
                SendChatMessage(player, "Syntax: /removehome {home}");
                return;
            }

            string home = args[0].ToLower();

            if (!GetHomes(player).Keys.Contains(home))
            {
                SendChatMessage(player, GetMessage("Unknown Home", player).Replace("{home}", home));
                return;
            }

            RemoveHome(player, home);
            SendChatMessage(player, GetMessage("Home Removed", player).Replace("{home}", home));
        }

        [ChatCommand("sethome")]
        private void CmdSetHome(PlayerSession player, string command, string[] args)
        {
            if (!HasPerm(player, "home"))
            {
                SendChatMessage(player, GetMessage("No Permission", player));
                return;
            }

            if (!_config.Home.Enabled)
                return;

            if (_config.Home.CheckForStakes && !HasStakeAuthority(player))
            {
                SendChatMessage(player, GetMessage("No Stake", player));
                return;
            }

            if (args.Length != 1)
            {
                SendChatMessage(player, "Syntax: /sethome {home}");
                return;
            }

            string home = args[0].ToLower();

            if (GetHomes(player).Keys.Contains(home))
            {
                SendChatMessage(player, GetMessage("Home Exists", player).Replace("{home}", home));
                return;
            }
            
            if (GetHomeCount(player) >= GetHomeLimit(player))
            {
                SendChatMessage(player, GetMessage("Max Homes", player).Replace("{count}", GetHomeLimit(player).ToString()));
                return;
            }

            AddHome(player, home);
            SendChatMessage(player, GetMessage("Home Set", player).Replace("{home}", home));
        }

        [ChatCommand("home")]
        private void CmdHome(PlayerSession player, string command, string[] args)
        {
            if (!HasPerm(player, "home"))
            {
                SendChatMessage(player, GetMessage("No Permission", player));
                return;
            }

            if (!_config.Home.Enabled)
                return;

            if (args.Length != 1)
            {
                SendChatMessage(player, "Syntax: /home {home}");
                return;
            }

            string home = args[0].ToLower();

            if (!GetHomes(player).Keys.Contains(home))
            {
                SendChatMessage(player, GetMessage("Unknown Home", player).Replace("{home}", home));
                return;
            }
            
            if (_config.Home.CooldownInMinutes > 0)
            {
                if (!_lastHome.ContainsKey(player.SteamId.m_SteamID))
                {
                    _lastHome[player.SteamId.m_SteamID] = DateTime.UtcNow;
                }
                else
                {
                    TimeSpan elapsedTime = DateTime.UtcNow.Subtract(_lastHome[player.SteamId.m_SteamID]);

                    if (elapsedTime.Minutes <= _config.Home.CooldownInMinutes)
                    {
                        float nextHome = _config.Home.CooldownInMinutes - elapsedTime.Minutes;

                        SendChatMessage(player, GetMessage("Home Cooldown", player).Replace("{time}", nextHome.ToString()));
                        return;
                    }

                    _lastHome[player.SteamId.m_SteamID] = DateTime.UtcNow;
                }
            }

            if (_config.Home.CheckForStakes && !HasStakeAuthority(player, _homes[player.SteamId.m_SteamID][home]))
            {
                SendChatMessage(player, GetMessage("Home Compromised", player));
                RemoveHome(player, home);
                return;
            }

            SendChatMessage(player,
                GetMessage("Teleporting Soon", player)
                    .Replace("{time}", _config.Home.TeleportTimer.ToString())
            );

            timer.Once(_config.Home.TeleportTimer, () =>
            {
                TeleportToLocation(player, _homes[player.SteamId.m_SteamID][home]);
                SendChatMessage(player, GetMessage("Home Teleported", player).Replace("{home}", home));
            });
        }

        [ChatCommand("homes")]
        private void CmdHomes(PlayerSession player, string command, string[] args)
        {
            if (!HasPerm(player, "home"))
            {
                SendChatMessage(player, GetMessage("No Permission", player));
                return;
            }

            if (!_config.Home.Enabled)
                return;

            if (GetHomeCount(player) == 0)
            {
                SendChatMessage(player, GetMessage("No Homes", player));
                return;
            }

            SendChatMessage(player,
                GetMessage("Home List", player)
                    .Replace("{homes}", GetHomes(player).Keys.ToSentence())
            );
        }

        private int GetHomeLimit(PlayerSession player)
        {
            int limit = _config.Home.HomeCountLimit;

            foreach (var kvp in _config.Home.HomeLimitPermissions)
                if (kvp.Value > limit && HasPerm(player, kvp.Key))
                    limit = kvp.Value;

            return limit;
        }

        private Dictionary<string, Vector3> GetHomes(PlayerSession player)
        {
            if (!_homes.ContainsKey(player.SteamId.m_SteamID))
                _homes.Add(player.SteamId.m_SteamID, new Dictionary<string, Vector3>());

            return _homes[player.SteamId.m_SteamID];
        }

        private int GetHomeCount(PlayerSession player) => GetHomes(player).Count;

        private void AddHome(PlayerSession player, string name)
        {
            if (!_homes.ContainsKey(player.SteamId.m_SteamID))
                _homes.Add(player.SteamId.m_SteamID, new Dictionary<string, Vector3>());
            
            _homes[player.SteamId.m_SteamID].Add(name, player.WorldPlayerEntity.transform.position);

            SaveData();
        }

        private void RemoveHome(PlayerSession player, string name)
        {
            if (!_homes.ContainsKey(player.SteamId.m_SteamID))
                return;

            _homes[player.SteamId.m_SteamID].Remove(name);

            SaveData();
        }

        #endregion

        #region Warps

        [ChatCommand("removewarp")]
        private void CmdRemoveWarp(PlayerSession player, string command, string[] args)
        {
            if (!HasPerm(player, "admin"))
            {
                SendChatMessage(player, GetMessage("No Permission", player));
                return;
            }

            if (args.Length != 1)
            {
                SendChatMessage(player, "Syntax: /removewarp {warp}");
                return;
            }

            string warp = args[0].ToLower();

            if (!_warps.ContainsKey(warp))
            {
                SendChatMessage(player, GetMessage("Unknown Warp", player).Replace("{warp}", warp));
                return;
            }

            RemoveWarp(warp);
            SendChatMessage(player, GetMessage("Warp Removed", player).Replace("{warp}", warp));
        }

        [ChatCommand("setwarp")]
        private void CmdSetWarp(PlayerSession player, string command, string[] args)
        {
            if (!HasPerm(player, "admin"))
            {
                SendChatMessage(player, GetMessage("No Permission", player));
                return;
            }

            if (args.Length != 1)
            {
                SendChatMessage(player, "Syntax: /setwarp {warp}");
                return;
            }

            string warp = args[0].ToLower();

            if (_warps.ContainsKey(warp))
            {
                SendChatMessage(player, GetMessage("Warp Exists", player).Replace("{warp}", warp));
                return;
            }

            CreateWarp(player, warp);
            SendChatMessage(player, GetMessage("Warp Set", player).Replace("{warp}", warp));
        }

        [ChatCommand("warp")]
        private void CmdWarp(PlayerSession player, string command, string[] args)
        {
            if (!HasPerm(player, "warp"))
            {
                SendChatMessage(player, GetMessage("No Permission", player));
                return;
            }

            if (!_config.Warp.Enabled)
                return;

            if (args.Length != 1)
            {
                SendChatMessage(player, "Syntax: /warp {warp}");
                return;
            }

            string warp = args[0].ToLower();

            if (!_warps.ContainsKey(warp))
            {
                SendChatMessage(player, GetMessage("Unknown Warp", player).Replace("{warp}", warp));
                return;
            }

            if (_config.Warp.CooldownInMinutes > 0 && _lastWarp.ContainsKey(player.SteamId.m_SteamID))
            {
                TimeSpan elapsedTime = DateTime.UtcNow.Subtract(_lastWarp[player.SteamId.m_SteamID]);

                if (elapsedTime.Minutes <= _config.Warp.CooldownInMinutes)
                {
                    float nextWarp = _config.Warp.CooldownInMinutes - elapsedTime.Minutes;

                    SendChatMessage(player,
                        GetMessage("Warp Cooldown", player)
                            .Replace("{time}", nextWarp.ToString())
                    );

                    return;
                }
            }

            _lastWarp[player.SteamId.m_SteamID] = DateTime.UtcNow;

            SendChatMessage(player, 
                GetMessage("Teleporting Soon", player)
                    .Replace("{time}", _config.Warp.TeleportTimer.ToString())
            );

            timer.Once(_config.Warp.TeleportTimer, () =>
            {
                TeleportToLocation(player, _warps[warp]);
                SendChatMessage(player, GetMessage("Warp Teleported", player).Replace("{warp}", warp));
            });
        }

        [ChatCommand("warps")]
        private void CmdWarps(PlayerSession player, string command, string[] args)
        {
            if (!HasPerm(player, "warp"))
            {
                SendChatMessage(player, GetMessage("No Permission", player));
                return;
            }

            if (!_config.Warp.Enabled)
                return;

            if (_warps.Count == 0)
                SendChatMessage(player, GetMessage("No Warps", player));
            else
                SendChatMessage(player, GetMessage("Warp List", player).Replace("{warps}", _warps.Keys.ToSentence()));
        }

        private void CreateWarp(PlayerSession player, string name)
        {
            if (_warps.ContainsKey(name))
                return;

            _warps.Add(name, player.WorldPlayerEntity.transform.position);

            SaveData();
        }

        private void RemoveWarp(string name)
        {
            if (!_warps.ContainsKey(name))
                return;

            _warps.Remove(name);

            SaveData();
        }

        #endregion

        #region Teleport Requests

        [ChatCommand("tpr")]
        private void CmdTpr(PlayerSession player, string command, string[] args)
        {
            if (!HasPerm(player, "tpr"))
            {
                SendChatMessage(player, GetMessage("No Permission", player));
                return;
            }

            if (!_config.TPR.Enabled)
                return;

            if (args.Length != 1)
            {
                SendChatMessage(player, "Syntax: /tpr {player}");
                return;
            }

            PlayerSession target = GetPlayer(args[0], player);
            if (target == null) return;

            if (target == player)
            {
                SendChatMessage(player, GetMessage("Teleport To Self", player));
                return;
            }

            if (_pendingRequests.ContainsValue(target) || _pendingRequests.ContainsKey(target))
            {
                SendChatMessage(player, GetMessage("Already Pending", player).Replace("{player}", target.Identity.Name));
                return;
            }

            if (_config.TPR.CooldownInMinutes > 0 && _lastTpr.ContainsKey(player.SteamId.m_SteamID))
            {
                TimeSpan elapsedTime = DateTime.UtcNow.Subtract(_lastTpr[player.SteamId.m_SteamID]);
                float nextTp = _config.TPR.CooldownInMinutes - elapsedTime.Minutes;

                if (elapsedTime.Minutes <= _config.TPR.CooldownInMinutes)
                {
                    SendChatMessage(player, GetMessage("TPR Cooldown", player).Replace("{time}", nextTp.ToString()));
                    return;
                }
            }

            SendRequest(player, target);
        }

        [ChatCommand("tpa")]
        private void CmdTpa(PlayerSession player, string command, string[] args)
        {
            if (!HasPerm(player, "tpr"))
            {
                SendChatMessage(player, GetMessage("No Permission", player));
                return;
            }

            if (!_config.TPR.Enabled)
                return;

            if (!_pendingRequests.ContainsValue(player))
            {
                SendChatMessage(player, GetMessage("No Pending", player));
                return;
            }

            PlayerSession source = _pendingRequests.Keys.FirstOrDefault(p => _pendingRequests[p] == player);

            if (source == null)
                return;

            if (!IsSafePlayer(player))
            {
                SendChatMessage(player, GetMessage("Target Location Unsafe", player));
                return;
            }

            if (_config.TPR.CooldownInMinutes > 0)
                _lastTpr[source.SteamId.m_SteamID] = DateTime.UtcNow;

            SendChatMessage(source, GetMessage("Accepted Request", player).Replace("{player}", player.Identity.Name));
            SendChatMessage(source, GetMessage("Teleporting Soon", source).Replace("{time}", _config.TPR.TeleportTimer.ToString()));

            if (_pendingTimers.ContainsKey(source))
                _pendingTimers[source].Destroy();

            if (_pendingRequests.ContainsKey(source))
                _pendingRequests.Remove(source);

            timer.Once(_config.TPR.TeleportTimer, () =>
            {
                SendChatMessage(source, GetMessage("Teleported", source).Replace("{target}", player.Identity.Name));
                TeleportToLocation(source, player.WorldPlayerEntity.gameObject.transform.position);

                if (_pendingTimers.ContainsKey(player))
                    _pendingTimers.Remove(player);
            });
        }

        private void SendRequest(PlayerSession player, PlayerSession target)
        {
            _pendingRequests[player] = target;

            SendChatMessage(player, GetMessage("Request Sent", player));
            SendChatMessage(target, GetMessage("Request Got", target).Replace("{player}", player.Identity.Name));

            _pendingTimers[player] = timer.Once(_config.TPR.PendingTimer, () =>
            {
                _pendingRequests.Remove(player);

                SendChatMessage(player, GetMessage("Request Ran Out", player));
                SendChatMessage(target, GetMessage("Request Ran Out", target));
            });
        }

        #endregion

        #region Helpers

        #region Teleportation

        private void TeleportToPlayer(PlayerSession player, PlayerSession target)
        {
            GameObject playerEntity = target.WorldPlayerEntity.gameObject;

            TeleportToLocation(player, playerEntity.transform.position);
        }

        private void TeleportToLocation(PlayerSession player, Vector3 location)
        {
            var hookResult = Interface.Call("CanTeleport", player, location);
            if (hookResult is bool && (bool) hookResult == false)
            {
                return;
            }

            GameObject playerEntity = player.WorldPlayerEntity.gameObject;

            playerEntity.transform.position = location;
        }

        #endregion

        #region Location Validation

        private bool HasStakeAuthority(PlayerSession player) => 
            HasStakeAuthority(player, player.WorldPlayerEntity.gameObject.transform.position);

        private bool HasStakeAuthority(PlayerSession player, Vector3 vector)
        {
            List<OwnershipStakeServer> entities = GetStakesInArea(vector, _config.Home.StakeRadius);
            return entities.Any(e => e.IsBuildAuthorized(player.Identity));
        }

        private List<OwnershipStakeServer> GetStakesInArea(Vector3 pos, float radius)
        {
            List<OwnershipStakeServer> entities = new List<OwnershipStakeServer>();

            foreach (OwnershipStakeServer entity in Resources.FindObjectsOfTypeAll<OwnershipStakeServer>())
            {
                if (Vector3.Distance(entity.transform.position, pos) <= radius)
                    entities.Add(entity);
            }

            return entities;
        }

        // Credit to Bankroll Tom
        public bool IsSafeLocation(Vector3 pos)
        {
            var playerCenterOffset = 1.1f; // offset from position to player center in Y-axis
            var crouchHalfHeight = .75f; // half the capsule height of crouching character
            var playerRadius = .36f;
            var capsuleBottom = pos + (playerCenterOffset - crouchHalfHeight + playerRadius) * Vector3.up;
            var capsuleTop = pos + (playerCenterOffset + crouchHalfHeight - playerRadius) * Vector3.up;

            if (Physics.CheckCapsule(capsuleBottom, capsuleTop, playerRadius, LayerMaskManager.TerrainConstructionsMachines, QueryTriggerInteraction.Ignore))
            {
                return false;
            }

            return !PhysicsHelpers.IsInRock(pos + Vector3.up * playerCenterOffset);
        }

        // Credit to Bankroll Tom
        public bool IsSafePlayer(PlayerSession player)
        {
            GameObject playerEntity = player.WorldPlayerEntity.gameObject;

            // unsafe to teleport to a player in vehicle
            if (playerEntity.GetComponent<CharacterMotorSimple>().InsideVehicle != null)
            {
                return false;
            }

            return IsSafeLocation(playerEntity.transform.position);
        }

        #endregion

        private PlayerSession GetPlayer(string nameOrID, PlayerSession player)
        {
            ulong steamId;
            if (TryParseSteamId(nameOrID, out steamId))
            {
                PlayerSession session = GameManager.Instance.GetSessions().Values
                    .FirstOrDefault(p => p.SteamId.m_SteamID == steamId);

                if (session == null)
                    SendChatMessage(player, $"Could not find player with ID '{nameOrID}'");

                return session;
            }

            List<PlayerSession> foundPlayers = new List<PlayerSession>();

            foreach (PlayerSession session in GameManager.Instance.GetSessions().Values)
            {
                if (session.Identity.Name.ToLower() == nameOrID.ToLower())
                    return session;

                if (session.Identity.Name.ToLower().Contains(nameOrID.ToLower()))
                    foundPlayers.Add(session);
            }

            switch (foundPlayers.Count)
            {
                case 0:
                    SendChatMessage(player, $"Could not find player with name '{nameOrID}'");
                    break;

                case 1:
                    return foundPlayers[0];

                default:
                    string[] names = foundPlayers
                        .Select(p => p.Identity.Name)
                        .ToArray();

                    SendChatMessage(player, "Multiple matching players found: \n" + string.Join(", ", names));
                    break;
            }

            return null;
        }

        private bool TryParseSteamId(string id, out ulong result)
        {
            if (id.Length == 17 && id.StartsWith("7656119") && ulong.TryParse(id, out result))
            {
                return true;
            }

            result = 0;
            return false;
        }

        private bool HasPerm(PlayerSession session, string perm) => 
            permission.UserHasPermission(session.SteamId.ToString(), $"{Name}.{perm}");

        private string GetMessage(string key, PlayerSession session) => lang.GetMessage(key, this, session.SteamId.ToString());

        private void SendChatMessage(PlayerSession player, string message)
        {
            hurt.SendChatMessage(player, null, message);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                { "No Permission", "You don't have permission to use this command." },
                { "Request Ran Out", "Your pending teleport request ran out of time." },
                { "Request Sent", "Teleport request sent." },
                { "Request Got", "{player} would like to teleport to you. Accept by typing /tpa." },
                { "Teleported", "You have been teleported to {target}." },
                { "Accepted Request", "{player} has accepted your teleport request." },
                { "No Pending", "You don't have a pending teleport request." },
                { "Already Pending", "{player} already has a teleport request pending." },
                { "Teleporting Soon", "You will be teleported in {time} seconds." },
                { "Teleport To Self", "You may not teleport to yourself." },
                { "No Homes", "You do not have any homes." },
                { "Home Set", "You have set your home '{home}'" },
                { "Home Removed", "You have removed your home '{home}'" },
                { "Home Exists", "You already have a home called '{home}'" },
                { "Home Teleported", "You have been teleported to your home '{home}'" },
                { "Home List", "Your Homes: {homes}" },
                { "Max Homes", "You may not have more than {count} homes!" },
                { "Unknown Home", "You don't have a home called '{home}'" },
                { "Home Compromised", "You are not authorized at any stakes near your home '{home}'. The home was therefore removed." },
                { "No Stake", "You need to be close to a stake you're authorized at to set a home." },
                { "Home Cooldown", "You need to wait {time} minutes before teleporting to a home again." },
                { "TPR Cooldown", "You need to wait {time} minutes before sending the next teleport request." },
                { "Warp Set", "You have set warp '{warp}' at your current location." },
                { "Warp Removed", "You have removed warp '{warp}'" },
                { "Warp Teleported", "You have been teleported to warp '{warp}'" },
                { "Unknown Warp", "There is no warp called '{warp}'" },
                { "Warp List", "Available Warps: {warps}" },
                { "Warp Exists", "There already is a warp called '{warp}'" },
                { "No Warps", "There are no warps set." },
                { "Warp Cooldown", "You need to wait {time} minutes before teleporting to a warp again." },
                { "Target Location Unsafe", "The target location is currently not safe to teleport to." }
            }, this);
        }

        #endregion

        #region Configuration

        protected override void LoadConfig()
        {
            base.LoadConfig();
            _config = Config.ReadObject<Configuration>();
            SaveConfig();
        }

        protected override void LoadDefaultConfig() => _config = new Configuration
        {
            Home =
            {
                HomeLimitPermissions =
                {
                    [$"{this.Name}.homelimit.basic"] = 1,
                    [$"{this.Name}.homelimit.extended"] = 2
                }
            }
        };

        protected override void SaveConfig() => Config.WriteObject(_config);

        private class Configuration
        {
            public TPRConfig TPR { get; set; } = new TPRConfig();
            public HomeConfig Home { get; set; } = new HomeConfig();
            public WarpConfig Warp { get; set; } = new WarpConfig();

            public class TPRConfig
            {
                public bool Enabled { get; set; } = true;

                [JsonProperty("Pending Timer (in seconds)")]
                public float PendingTimer { get; set; } = 30f;

                [JsonProperty("Teleport Timer (in seconds)")]
                public float TeleportTimer { get; set; } = 15f;

                [JsonProperty("Cooldown (in minutes)")]
                public float CooldownInMinutes { get; set; } = 5f;
            }

            public class HomeConfig
            {
                public bool Enabled { get; set; } = true;

                [JsonProperty("Check for Stakes (true/false)")]
                public bool CheckForStakes { get; set; } = true;

                [JsonProperty("Stake Detection Radius")]
                public float StakeRadius { get; set; } = 10f;

                [JsonProperty("Teleport Timer (in seconds)")]
                public float TeleportTimer { get; set; } = 15f;

                [JsonProperty("Cooldown (in minutes)")]
                public float CooldownInMinutes { get; set; } = 5f;

                [JsonProperty("Home Count Limit")]
                public int HomeCountLimit { get; set; } = 3;

                [JsonProperty("Home Count Limits (granted by permissions)")]
                public Dictionary<string, int> HomeLimitPermissions { get; set; } = new Dictionary<string, int>();
            }

            public class WarpConfig
            {
                public bool Enabled { get; set; } = true;

                [JsonProperty("Teleport Timer (in seconds)")]
                public float TeleportTimer { get; set; } = 15f;

                [JsonProperty("Cooldown (in minutes)")]
                public float CooldownInMinutes { get; set; } = 10f;
            }
        }

        #endregion
    }
}
using System;
using System.Collections.Generic;

using CodeHatch.Common;
using CodeHatch.Engine.Behaviours;
using CodeHatch.Engine.Networking;
using CodeHatch.TerrainAPI;
using CodeHatch.UserInterface.Dialogues;

using Oxide.Core.Libraries.Covalence;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("3D Teleporter", "GeniusPlayUnique", "2.0.0")]
    [Description("A three dimentional teleporter.")] /**(© GeniusPlayUnique)*/
    class Teleporter : ReignOfKingsPlugin
    {
        readonly static string license = ""
            + "License Agreement for (the) 'Teleporter.cs' [ReignOfKingsPlugin]: "
            + "With uploading this plugin to umod.org the rights holder (GeniusPlayUnique) grants the user the right to download and for usage of this plugin. "
            + "However these rights do NOT include the right to (re-)upload this plugin nor any modified version of it to umod.org or any other webside or to distribute it further in any way without written permission of the rights holder. "
            + "It is explicity allowed to modify this plugin at any time for personal usage ONLY. "
            + "If a modification should be made available for all users, please contact GeniusPlayUnique (rights holder) via umod.org to discuss the matter and the terms under which to gain permission to do so. "
            + "By changing 'Accept License Agreement' below to 'true' you accept this License Agreement.";
        static bool LicenseAgreementAccepted;

        protected override void LoadDefaultConfig()
        {
            Config["EULA", "License", "License Agreement"] = license;
            Config["EULA", "License Acceptance", "Accept License Agreement"] = new bool();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LicenseAgreementError"] = "Before using the [i]Teleporter.cs[/i] - plugin you need to accept the 'License Agreement' in the config-file.",
                ["TargetPlayerNotFound"] = "Unable to find target player with the name '{0}'.",
                ["OnlineTargetPlayerNotFound"] = "Unable to find player online with the name '{0}'.",
                ["UnableToTeleport"] = "Unable to teleport.",
                ["HeightWarningTitle"] = "[FF0000][i][u]Height Warning[/u]:[/i][FFFFFF]",
                ["HeightWarningSolidStructureText"] = "You are trying to teleport into a solid structure at the target coordinates. \n\n\n Resume teleportation process?",
                ["HeightWarningTerrainText"] = "You are trying to teleport {0}m below the calculated terrain height at the target coordinates. \n\n\n Resume teleportation process?",
                ["Confirm"] = "Confirm",
                ["Cancel"] = "Cancel",
                ["TeleportLog"] = "{0} teleported {1} to x: {2} y: {3} z: {4}."
            }, this, "en");
        }

        void Init()
        {
            if (!Config["EULA", "License", "License Agreement"].Equals(license))
            {
                LoadDefaultConfig();
            }

            LoadConfig();
            LicenseAgreementAccepted = Convert.ToBoolean(Config["EULA", "License Acceptance", "Accept License Agreement"]);

            permission.RegisterPermission("3D.teleport", this);
        }

        [ChatCommand("tpdelay")]
        void GetCoordinatesAndDelay(Player player, string command, string[] args)
        {
            if (!LicenseAgreementAccepted)
            {
                player.SendError(lang.GetMessage("LicenseAgreementError", this, player.Id.ToString()));
                return;
            }

            IPlayer iPlayer = covalence.Players.FindPlayerById(player.Id.ToString());

            if (!player.HasPermission("rok.teleport") && !iPlayer.HasPermission("3D.teleport")) return;

            LockTargetCoordinates(player, command, args);
        }

        [ChatCommand("tp")]
        void LockTargetCoordinates(Player player, string command, string[] args)
        {
            if (!LicenseAgreementAccepted)
            {
                player.SendError(lang.GetMessage("LicenseAgreementError", this, player.Id.ToString()));
                return;
            }

            IPlayer iPlayer = covalence.Players.FindPlayerById(player.Id.ToString());

            if (!player.HasPermission("rok.teleport") && !iPlayer.HasPermission("3D.teleport")) return;

            float f = 0;
            float x = 0;
            float y = 0;
            float z = 0;
            float delay = 0;

            if(args.Length == 0)
            {
                if (command.ToLower().Equals("tpdelay"))
                {
                    player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                    return;
                }

                x = 0;
                z = 0;

                y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                {
                    y--;
                }

                while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                {
                    y++;
                }

                Teleport(player, iPlayer, x, y, z);
            }
            else if (args.Length == 1)
            {
                if (command.ToLower().Equals("tpdelay"))
                {
                    if (float.TryParse(args[args.Length - 1], out f))
                    {
                        float.TryParse(args[args.Length - 1], out delay);

                        if (delay <= 0)
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }
                    }
                    else
                    {
                        player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                        return;
                    }

                    x = 0;
                    z = 0;

                    y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y;

                    while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                    {
                        y--;
                    }

                    while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                    {
                        y++;
                    }

                    float xNew = player.Entity.Position.x;
                    float yNew = player.Entity.Position.y;
                    float zNew = player.Entity.Position.z;

                    timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                    Teleport(player, iPlayer, x, y, z);
                    return;
                }

                try
                {
                    Player targetPlayer = Server.GetPlayerByName(args[0]);

                    x = targetPlayer.Entity.Position.x;
                    y = targetPlayer.Entity.Position.y;
                    z = targetPlayer.Entity.Position.z;
                }
                catch (Exception)
                {
                    player.SendError(string.Format(lang.GetMessage("TargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                    return;
                }

                GetBestPointAndTeleport(player, iPlayer, x, y, z);
            }
            else if (args.Length == 2)
            {
                if (float.TryParse(args[0], out f) && float.TryParse(args[1], out f))
                {
                    float.TryParse(args[0], out x);
                    float.TryParse(args[1], out z);

                    y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                    while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                    {
                        y--;
                    }

                    while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                    {
                        y++;
                    }

                    Teleport(player, iPlayer, x, y, z);
                }
                else
                {
                    Player targetPlayerOne;

                    try
                    {
                        targetPlayerOne = Server.GetPlayerByName(args[0]);
                        iPlayer = covalence.Players.FindPlayerById(targetPlayerOne.Id.ToString());
                    }
                    catch (Exception)
                    {
                        player.SendError(string.Format(lang.GetMessage("OnlineTargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                        return;
                    }

                    if (command.ToLower().Equals("tpdelay"))
                    {
                        iPlayer = covalence.Players.FindPlayerById(player.Id.ToString());

                        if (float.TryParse(args[args.Length - 1], out f))
                        {
                            float.TryParse(args[args.Length - 1], out delay);

                            if (delay < 0)
                            {
                                player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                                return;
                            }

                            x = targetPlayerOne.Entity.Position.x;
                            y = targetPlayerOne.Entity.Position.y;
                            z = targetPlayerOne.Entity.Position.z;

                            float xNew = player.Entity.Position.x;
                            float yNew = player.Entity.Position.y;
                            float zNew = player.Entity.Position.z;

                            timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                            GetBestPointAndTeleport(player, iPlayer, x, y, z);
                        }
                        else
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }
                    }
                    else
                    {
                        try
                        {
                            Player targetPlayerTwo = Server.GetPlayerByName(args[1]);

                            x = targetPlayerTwo.Entity.Position.x;
                            y = targetPlayerTwo.Entity.Position.y;
                            z = targetPlayerTwo.Entity.Position.z;
                        }
                        catch (Exception)
                        {
                            player.SendError(string.Format(lang.GetMessage("TargetPlayerNotFound", this, player.Id.ToString()), args[1]));
                            return;
                        }
                    }

                    GetBestPointAndTeleport(player, iPlayer, x, y, z);
                }
            }
            else if (args.Length == 3)
            {
                if (float.TryParse(args[0], out f) && float.TryParse(args[1], out f) && float.TryParse(args[2], out f))
                {
                    if (command.ToLower().Equals("tpdelay"))
                    {
                        float.TryParse(args[args.Length - 1], out delay);

                        if (delay <= 0)
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }

                        float.TryParse(args[0], out x);
                        float.TryParse(args[1], out z);

                        y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                        while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                        {
                            y--;
                        }

                        while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                        {
                            y++;
                        }

                        float xNew = player.Entity.Position.x;
                        float yNew = player.Entity.Position.y;
                        float zNew = player.Entity.Position.z;

                        timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                        Teleport(player, iPlayer, x, y, z);
                    }
                    else
                    {
                        float.TryParse(args[0], out x);
                        float.TryParse(args[1], out y);
                        float.TryParse(args[2], out z);

                        Vector3 targetVector = new Vector3(x, z);

                        if (TeleportUtil.IsPointBlocked(new Vector3(x, y, z), 0.5f) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z), 0.5f))
                        {
                            if ((y - TerrainAPIBase.GetTerrainHeightAt(targetVector)) <= 0)
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), string.Format(lang.GetMessage("HeightWarningTerrainText", this, player.Id.ToString()), (Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(targetVector))).ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, 0, 0, 0, 0, options, dialogue, data));
                            }
                            else
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), lang.GetMessage("HeightWarningSolidStructureText", this, player.Id.ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, 0, 0, 0, 0, options, dialogue, data));
                            }
                        }
                        else
                        {
                            Teleport(player, iPlayer, x, y, z);
                        }
                    }
                }
                else if (float.TryParse(args[1], out f) && float.TryParse(args[2], out f))
                {
                    try
                    {
                        Player targetPlayer = Server.GetPlayerByName(args[0]);
                        iPlayer = covalence.Players.FindPlayerById(targetPlayer.Id.ToString());
                    }
                    catch (Exception)
                    {
                        player.SendError(string.Format(lang.GetMessage("OnlineTargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                        return;
                    }

                    float.TryParse(args[1], out x);
                    float.TryParse(args[2], out z);

                    y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y;

                    while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                    {
                        y--;
                    }

                    while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                    {
                        y++;
                    }

                    Teleport(player, iPlayer, x, y, z);
                }
                else if (float.TryParse(args[args.Length - 1], out f))
                {
                    if (command.ToLower().Equals("tpdelay"))
                    {
                        float.TryParse(args[args.Length - 1], out delay);

                        if (delay <= 0)
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }

                        Player targetPlayerOne;

                        try
                        {
                            targetPlayerOne = Server.GetPlayerByName(args[0]);
                            iPlayer = covalence.Players.FindPlayerById(targetPlayerOne.Id.ToString());
                        }
                        catch (Exception)
                        {
                            player.SendError(string.Format(lang.GetMessage("OnlineTargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                            return;
                        }

                        try
                        {
                            Player targetPlayerTwo = Server.GetPlayerByName(args[1]);

                            x = targetPlayerTwo.Entity.Position.x;
                            y = targetPlayerTwo.Entity.Position.y;
                            z = targetPlayerTwo.Entity.Position.z;
                        }
                        catch (Exception)
                        {
                            player.SendError(string.Format(lang.GetMessage("TargetPlayerNotFound", this, player.Id.ToString()), args[1]));
                            return;
                        }

                        float xNew = targetPlayerOne.Entity.Position.x;
                        float yNew = targetPlayerOne.Entity.Position.y;
                        float zNew = targetPlayerOne.Entity.Position.z;

                        timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                        GetBestPointAndTeleport(player, iPlayer, x, y, z);
                    }
                    else
                    {
                        player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                        return;
                    }
                }
                else
                {
                    player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                    return;
                }
            }
            else if (args.Length == 4)
            {
                if (float.TryParse(args[0], out f) && float.TryParse(args[1], out f) && float.TryParse(args[2], out f) && float.TryParse(args[3], out f))
                {
                    if (command.ToLower().Equals("tpdelay"))
                    {
                        float.TryParse(args[args.Length - 1], out delay);

                        if (delay <= 0)
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }

                        float.TryParse(args[0], out x);
                        float.TryParse(args[1], out y);
                        float.TryParse(args[2], out z);

                        float xNew = player.Entity.Position.x;
                        float yNew = player.Entity.Position.y;
                        float zNew = player.Entity.Position.z;

                        Vector3 targetVector = new Vector3(x, z);

                        if (TeleportUtil.IsPointBlocked(new Vector3(x, y, z), 0.5f) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z), 0.5f))
                        {
                            if ((y - TerrainAPIBase.GetTerrainHeightAt(targetVector)) <= 0)
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), string.Format(lang.GetMessage("HeightWarningTerrainText", this, player.Id.ToString()), (Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(targetVector))).ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, xNew, yNew, zNew, delay, options, dialogue, data));
                            }
                            else
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), lang.GetMessage("HeightWarningSolidStructureText", this, player.Id.ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, delay, xNew, yNew, zNew, options, dialogue, data));
                            }
                        }
                        else
                        {
                            timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                            Teleport(player, iPlayer, x, y, z);
                        }
                    }
                }
                else if (float.TryParse(args[1], out f) && float.TryParse(args[2], out f) && float.TryParse(args[3], out f))
                {
                    if (command.ToLower().Equals("tpdelay"))
                    {
                        float.TryParse(args[args.Length - 1], out delay);

                        if (delay <= 0)
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }

                        Player targetPlayer;

                        try
                        {
                            targetPlayer = Server.GetPlayerByName(args[0]);
                            iPlayer = covalence.Players.FindPlayerById(targetPlayer.Id.ToString());
                        }
                        catch (Exception)
                        {
                            player.SendError(string.Format(lang.GetMessage("OnlineTargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                            return;
                        }

                        float.TryParse(args[1], out x);
                        float.TryParse(args[2], out z);

                        y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                        while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                        {
                            y--;
                        }

                        while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                        {
                            y++;
                        }

                        float xNew = targetPlayer.Entity.Position.x;
                        float yNew = targetPlayer.Entity.Position.y;
                        float zNew = targetPlayer.Entity.Position.z;

                        timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                        Teleport(player, iPlayer, x, y, z);
                    }
                    else
                    {
                        try
                        {
                            Player targetPlayer = Server.GetPlayerByName(args[0]);
                            iPlayer = covalence.Players.FindPlayerById(targetPlayer.Id.ToString());
                        }
                        catch (Exception)
                        {
                            player.SendError(string.Format(lang.GetMessage("OnlineTargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                            return;
                        }

                        float.TryParse(args[1], out x);
                        float.TryParse(args[2], out y);
                        float.TryParse(args[3], out z);

                        Vector3 targetVector = new Vector3(x, z);

                        if (TeleportUtil.IsPointBlocked(new Vector3(x, y, z), 0.5f) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z), 0.5f))
                        {
                            if ((y - TerrainAPIBase.GetTerrainHeightAt(targetVector)) <= 0)
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), string.Format(lang.GetMessage("HeightWarningTerrainText", this, player.Id.ToString()), (Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(targetVector))).ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, 0, 0, 0, 0, options, dialogue, data));
                            }
                            else
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), lang.GetMessage("HeightWarningSolidStructureText", this, player.Id.ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, 0, 0, 0, 0, options, dialogue, data));
                            }
                        }
                        else
                        {
                            Teleport(player, iPlayer, x, y, z);
                        }
                    }
                }
                else
                {
                    player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                }
            }
            else if (args.Length == 5)
            {
                if (float.TryParse(args[1], out f) && float.TryParse(args[2], out f) && float.TryParse(args[3], out f) && float.TryParse(args[4], out f))
                {
                    if (command.ToLower().Equals("tpdelay"))
                    {
                        float.TryParse(args[args.Length - 1], out delay);

                        if (delay <= 0)
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }

                        Player targetPlayer;

                        try
                        {
                            targetPlayer = Server.GetPlayerByName(args[0]);
                            iPlayer = covalence.Players.FindPlayerById(targetPlayer.Id.ToString());
                        }
                        catch (Exception)
                        {
                            player.SendError(string.Format(lang.GetMessage("OnlineTargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                            return;
                        }

                        float.TryParse(args[1], out x);
                        float.TryParse(args[2], out y);
                        float.TryParse(args[3], out z);

                        float xNew = targetPlayer.Entity.Position.x;
                        float yNew = targetPlayer.Entity.Position.y;
                        float zNew = targetPlayer.Entity.Position.z;

                        Vector3 targetVector = new Vector3(x, z);

                        if (TeleportUtil.IsPointBlocked(new Vector3(x, y, z), 0.5f) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z), 0.5f))
                        {
                            if ((y - TerrainAPIBase.GetTerrainHeightAt(targetVector)) <= 0)
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), string.Format(lang.GetMessage("HeightWarningTerrainText", this, player.Id.ToString()), (Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(targetVector))).ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, delay, xNew, yNew, zNew, options, dialogue, data));
                            }
                            else
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), lang.GetMessage("HeightWarningSolidStructureText", this, player.Id.ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, delay, xNew, yNew, zNew, options, dialogue, data));
                            }
                        }
                        else
                        {
                            timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                            Teleport(player, iPlayer, x, y, z);
                        }
                    }
                    else
                    {
                        player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                    }
                }
                else
                {
                    player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                }
            }
            else
            {
                player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
            }
        }

        void GetBestPointAndTeleport(Player player, IPlayer iPlayer, float x, float y, float z)
        {
            double ii = Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(new Vector3((x + 1), (z + 1))));
            double id = Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(new Vector3((x + 1), (z - 1))));
            double di = Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(new Vector3((x - 1), (z + 1))));
            double dd = Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(new Vector3((x - 1), (z - 1))));

            double Iii;
            double Iid;
            double Idi;
            double Idd;

            double Dii;
            double Did;
            double Ddi;
            double Ddd;

            float newY = y;

            while (TeleportUtil.IsPointBlocked(new Vector3((x + 1), newY, (z + 1))) || TeleportUtil.IsPointBlocked(new Vector3((x + 1), (newY + 1), (z + 1))))
            {
                newY++;
            }

            Iii = Math.Abs(y - newY);

            newY = y;

            while (TeleportUtil.IsPointBlocked(new Vector3((x + 1), newY, (z - 1))) || TeleportUtil.IsPointBlocked(new Vector3((x + 1), (newY + 1), (z - 1))))
            {
                newY++;
            }

            Iid = Math.Abs(y - newY);

            newY = y;

            while (TeleportUtil.IsPointBlocked(new Vector3((x - 1), newY, (z + 1))) || TeleportUtil.IsPointBlocked(new Vector3((x - 1), (newY + 1), (z + 1))))
            {
                newY++;
            }

            Idi = Math.Abs(y - newY);

            newY = y;

            while (TeleportUtil.IsPointBlocked(new Vector3((x - 1), newY, (z - 1))) || TeleportUtil.IsPointBlocked(new Vector3((x - 1), (newY + 1), (z - 1))))
            {
                newY++;
            }

            Idd = Math.Abs(y - newY);

            newY = y;

            while (!TeleportUtil.IsPointBlocked(new Vector3((x + 1), (newY - 1), (z + 1))))
            {
                newY--;
            }

            Dii = Math.Abs(y - newY);

            newY = y;

            while (!TeleportUtil.IsPointBlocked(new Vector3((x + 1), (newY - 1), (z - 1))))
            {
                newY--;
            }

            Did = Math.Abs(y - newY);

            newY = y;

            while (!TeleportUtil.IsPointBlocked(new Vector3((x - 1), (newY - 1), (z + 1))))
            {
                newY--;
            }

            Ddi = Math.Abs(y - newY);

            newY = y;

            while (!TeleportUtil.IsPointBlocked(new Vector3((x - 1), (newY - 1), (z - 1))))
            {
                newY--;
            }

            Ddd = Math.Abs(y - newY);

            if (Iii >= Dii)
            {
                ii = Iii;
            }
            else
            {
                ii = Dii;
            }

            if (Iid >= Did)
            {
                id = Iid;
            }
            else
            {
                id = Did;
            }

            if (Idi >= Ddi)
            {
                di = Idi;
            }
            else
            {
                di = Ddi;
            }

            if (Idd >= Ddd)
            {
                dd = Idd;
            }
            else
            {
                dd = Ddd;
            }

            if (ii <= id && ii <= di && ii <= dd)
            {
                x++;
                z++;

                y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                {
                    y--;
                }

                while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                {
                    y++;
                }
            }
            else if (id <= ii && id <= di && id <= dd)
            {
                x++;
                z--;

                y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                {
                    y--;
                }

                while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                {
                    y++;
                }
            }
            else if (di <= ii && id <= di && di <= dd)
            {
                x--;
                z++;

                y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                {
                    y--;
                }

                while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                {
                    y++;
                }
            }
            else if (dd <= ii && dd <= id && dd <= di)
            {
                x--;
                z--;

                y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                {
                    y--;
                }

                while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                {
                    y++;
                }
            }

            Teleport(player, iPlayer, x, y, z);
        }

        void HeightWarning(Player player, IPlayer iPlayer, string command, float x, float y, float z, float delay, float xNew, float yNew, float zNew, Options options, Dialogue dialogue, object data)
        {
            if (options.Equals(Options.Cancel) || options.Equals(Options.No))
            {
                return;
            }
            else
            {
                if (command.ToLower().Equals("tpdelay"))
                {
                    timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));
                }

                Teleport(player, iPlayer, x, y, z);
            }
        }

        void Teleport(Player player, IPlayer iPlayer, float x, float y, float z)
        {
            iPlayer.Teleport(x, y, z);

            Puts(string.Format(lang.GetMessage("TeleportLog", this), player.Name, iPlayer.Name, x.ToString(), y.ToString(), z.ToString()));
        }
    }
}
using Newtonsoft.Json;
using Oxide.Core.Libraries.Covalence;
using Oxide.Core;
using ProtoBuf;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("MapNote Teleport", "MON@H", "2.2.1")]
    [Description("Teleports player to marker on map when placed.")]
    public class MapNoteTeleport : CovalencePlugin
    {
        #region Initialization

        private const string PermissionUse = "BTeleportMap.MapTP";
        private readonly List<ulong> _playersOnCooldown = new List<ulong> ();
        private readonly List<ulong> _playersWithGodMode = new List<ulong> ();

        private void Init()
        {
            LoadData();
            permission.RegisterPermission(PermissionUse, this);
            foreach (var command in _configData.GlobalSettings.Commands)
            {
                AddCovalenceCommand(command, nameof(CmdMapNoteTeleport));
            }
            Unsubscribe(nameof(OnEntityTakeDamage));
        }

        private void OnServerInitialized()
        {
            if (_configData.GlobalSettings.Commands.Length == 0)
            {
                _configData.GlobalSettings.Commands = new[] { "mnt" };
                SaveConfig();
            } 
        }

        private void OnServerSave() => timer.Once(UnityEngine.Random.Range(0f, 60f), SaveData);

        private void Unload()
        {
            SaveData();
        }

        #endregion Initialization

        #region Configuration

        private ConfigData _configData;

        private class ConfigData
        {
            [JsonProperty(PropertyName = "Global settings")]
            public GlobalConfiguration GlobalSettings = new GlobalConfiguration();

            [JsonProperty(PropertyName = "Chat settings")]
            public ChatConfiguration ChatSettings = new ChatConfiguration();

            public class GlobalConfiguration
            {
                [JsonProperty(PropertyName = "Use permissions")]
                public bool UsePermission = true;

                [JsonProperty(PropertyName = "Allow admins to use without permission")]
                public bool AdminsAllowed = true;

                [JsonProperty(PropertyName = "Default Enabled")]
                public bool DefaultEnabled = true;

                [JsonProperty(PropertyName = "Default Cooldown")]
                public float DefaultCooldown = 0f;

                [JsonProperty(PropertyName = "Maximum Cooldown")]
                public float MaximumCooldown = 0f;

                [JsonProperty(PropertyName = "Minimum Cooldown")]
                public float MinimumCooldown = -f;

                [JsonProperty(PropertyName = "GodMode Cooldown")]
                public float GodModeCooldown = 0f;

                [JsonProperty(PropertyName = "Commands list")]
                public string[] Commands = new[] { "mt", "maptp" };
            }

            public class ChatConfiguration
            {
                [JsonProperty(PropertyName = "Chat steamID icon")]
                public ulong SteamIDIcon = 0;

                [JsonProperty(PropertyName = "Notifications Enabled by default")]
                public bool DefaultNotification = true;
            }
        }

        protected override void LoadConfig()
        {
            base.LoadConfig();
            try
            {
                _configData = Config.ReadObject<ConfigData>();
                if (_configData == null)
                {
                    LoadDefaultConfig();
                    SaveConfig();
                }
            }
            catch
            {
                PrintError("The configuration file is corrupted");
                LoadDefaultConfig();
                SaveConfig();
            }
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("Creating a new configuration file");
            _configData = new ConfigData();
        }

        protected override void SaveConfig() => Config.WriteObject(_configData);

        #endregion Configuration

        #region DataFile

        private StoredData _storedData;

        private class StoredData
        {
            public readonly Dictionary<ulong, PlayerData> PlayerData = new Dictionary<ulong, PlayerData>();
        }

        public class PlayerData
        {
            public bool Enabled;
            public float Cooldown;
            public bool Notification;
        }

        private PlayerData GetPlayerData(ulong playerId, bool addToStored = false)
        {
            PlayerData playerData;
            if (!_storedData.PlayerData.TryGetValue(playerId, out playerData))
            {
                playerData = new PlayerData
                {
                    Enabled = _configData.GlobalSettings.DefaultEnabled,
                    Cooldown = _configData.GlobalSettings.DefaultCooldown,
                    Notification = _configData.ChatSettings.DefaultNotification,
                };

                if (addToStored)
                {
                    _storedData.PlayerData.Add(playerId, playerData);
                }
            }

            return playerData;
        }

        private void LoadData()
        {
            try
            {
                _storedData = Interface.Oxide.DataFileSystem.ReadObject<StoredData>(Name);
            }
            catch
            {
                _storedData = null;
            }
            finally
            {
                if (_storedData == null)
                {
                    ClearData();
                }
            }
        }

        private void SaveData() => Interface.Oxide.DataFileSystem.WriteObject(Name, _storedData);

        private void ClearData()
        {
            _storedData = new StoredData();
            SaveData();
        }

        #endregion DataFile

        #region Localization

        private string Lang(string key, string id = null, params object[] args) => string.Format(lang.GetMessage(key, this, id), args);

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CooldownEnded"] = "Cooldown is now ended. You can teleport again.",
                ["GodModeEnded"] = "Godmode is now <color=#B22222>Disabled</color>.",
                ["Disabled"] = "<color=#B22222>Disabled</color>",
                ["Enabled"] = "<color=#228B22>Enabled</color>",
                ["MapNoteTeleport"] = "Teleporting to map marker is now {0}",
                ["MapNoteTeleportCooldown"] = "Teleporting to map marker Cooldown set to <color=#FFA500>{0}</color>s.",
                ["MapNoteTeleportCooldownLimit"] = "Teleporting to map marker Cooldown allowed is between <color=#FFA500>{0}</color>s and <color=#FFA500>{1}</color>s",
                ["MapNoteTeleportDead"] = "You can't teleport while being dead!",
                ["MapNoteTeleportMounted"] = "You can't teleport while seated!",
                ["MapNoteTeleportNotification"] = "Notification to chat is now {0}",
                ["NotAllowed"] = "You do not have permission to use this command!",
                ["Prefix"] = "<color=#00FFFF>[MapNote Teleport]</color>: ",
                ["Teleported"] = "Teleported to <color=#FFA500>{0}</color>. Godmode is now <color=#228B22>Enabled</color> for <color=#FFA500>{1}</color>s. Teleport is on Cooldown for <color=#FFA500>{2}</color>s.",

                ["SyntaxError"] = "Syntax error occured!\n"
                + "<color=#FFFF00>/{0} <time (seconds)></color> - Set teleport Cooldown time, the allowed time is between <color=#FFA500>{1}</color>s and <color=#FFA500>{2}</color>s.\n"
                + "<color=#FFFF00>/{0} <t | toggle></color> - Enable/Disable teleporting to map marker\n"
                + "<color=#FFFF00>/{0} <n | notify></color> - Enable/Disable notification to chat",
            }, this);
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["CooldownEnded"] = "Перезарядка завершена. Можете телепортироваться снова.",
                ["GodModeEnded"] = "Неуязвимость <color=#B22222>Откл.</color>.",
                ["Disabled"] = "<color=#B22222>Откл.</color>",
                ["Enabled"] = "<color=#228B22>Вкл.</color>",
                ["MapNoteTeleport"] = "Телепортация к маркеру на карте сейчас {0}",
                ["MapNoteTeleportCooldown"] = "Время перезарядки телепорта к маркеру на карте установлено на <color=#FFA500>{0}</color> секунд.",
                ["MapNoteTeleportCooldownLimit"] = "Значение времени перезарядки телепорта к маркеру на карте должно быть между <color=#FFA500>{0}</color> сек и <color=#FFA500>{1}</color> сек",
                ["MapNoteTeleportDead"] = "Вы не можете телепортироваться, пока мертвы!",
                ["MapNoteTeleportMounted"] = "Вы не можете телепортироваться, когда сидите!",
                ["MapNoteTeleportNotification"] = "Уведомления в чат сейчас {0}",
                ["NotAllowed"] = "У вас нет разрешения на использование этой команды!",
                ["Prefix"] = "<color=#00FFFF>[MapNote Teleport]</color>: ",
                ["Teleported"] = "Вы телепортированы на <color=#FFA500>{0}</color>. Неуязвимость <color=#228B22>Вкл.</color> на <color=#FFA500>{1}</color> сек. Перезарядка телепорта <color=#FFA500>{2}</color> сек.",

                ["SyntaxError"] = "Синтаксическая ошибка!\n"
                + "<color=#FFFF00>/{0} <время (сек.)></color> - Установить время перезарядки телепорта к маркеру на карте. Значение должно быть между <color=#FFA500>{1}</color> сек. и <color=#FFA500>{2}</color> сек.\n"
                + "<color=#FFFF00>/{0} <t | toggle></color> - Вкл./Откл. телепортацию к маркеру на карте\n"
                + "<color=#FFFF00>/{0} <n | notify></color> - Вкл./Откл. уведомления в чат",
            }, this, "ru");
        }

        #endregion Localization

        #region Commands

        private void CmdMapNoteTeleport(IPlayer player, string command, string[] args)
        {

            if (_configData.GlobalSettings.UsePermission && !permission.UserHasPermission(player.Id, PermissionUse))
            {
                if (!_configData.GlobalSettings.AdminsAllowed || !player.IsAdmin)
                {
                    Print(player, Lang("NotAllowed", player.Id));
                    return;
                }
            }

            if (args == null || args.Length == 0)
            {
                Print(player, Lang("SyntaxError", player.Id, _configData.GlobalSettings.Commands[0], _configData.GlobalSettings.MinimumCooldown, _configData.GlobalSettings.MaximumCooldown));
                return;
            }

            var playerData = GetPlayerData(ulong.Parse(player.Id), true);

            float Cooldown;
            if (float.TryParse(args[0], out Cooldown))
            {
                if (Cooldown <= _configData.GlobalSettings.MaximumCooldown && Cooldown >= _configData.GlobalSettings.MinimumCooldown)
                {
                    playerData.Cooldown = Cooldown;
                    if (!playerData.Enabled)
                    {
                        playerData.Enabled = true;
                    }

                    Print(player, Lang("MapNoteTeleportCooldown", player.Id, Cooldown));
                    return;
                }

                Print(player, Lang("MapNoteTeleportCooldownLimit", player.Id, _configData.GlobalSettings.MinimumCooldown, _configData.GlobalSettings.MaximumCooldown));
                return;
            }

            switch (args[0].ToLower())
            {
                case "t":
                case "toggle":
                    playerData.Enabled = !playerData.Enabled;
                    Print(player, Lang("MapNoteTeleport", player.Id, playerData.Enabled ? Lang("Enabled", player.Id) : Lang("Disabled", player.Id)));
                    return;
                case "n":
                case "notify":
                    playerData.Notification = !playerData.Notification;
                    Print(player, Lang("MapNoteTeleportNotification", player.Id, playerData.Notification ? Lang("Enabled", player.Id) : Lang("Disabled", player.Id)));
                    return;
            }

            Print(player, Lang("SyntaxError", player.Id, _configData.GlobalSettings.Commands[0], _configData.GlobalSettings.MinimumCooldown, _configData.GlobalSettings.MaximumCooldown));
        }

        #endregion Commands

        #region Helpers

        private void TeleportToNote(BasePlayer player, MapNote note)
        {
            var err = CheckPlayer(player);
            if (err != null)
            {
                Print(player.IPlayer, Lang(err, player.UserIDString));
                return;
            }

            ulong userID = player.userID;
            _playersOnCooldown.Add(userID);
            _playersWithGodMode.Add(userID);
            Subscribe(nameof(OnEntityTakeDamage));
            player.flyhackPauseTime = _configData.GlobalSettings.MaximumCooldown;
            var pos = note.worldPosition;
            pos.y = GetGroundPosition(pos);

            player.Teleport(pos);
            player.RemoveFromTriggers();
            player.ForceUpdateTriggers();
            var playerData = GetPlayerData(userID);
            if (playerData.Notification)
            {
                Print(player.IPlayer, Lang("Teleported", player.UserIDString, pos, _configData.GlobalSettings.GodModeCooldown, playerData.Cooldown));
            }

            timer.Once(playerData.Cooldown, () =>
            {
                _playersOnCooldown.Remove(userID);

                if (playerData.Notification && player != null)
                {
                    Print(player.IPlayer, Lang("CooldownEnded", player.UserIDString));
                }
            });

            timer.Once(_configData.GlobalSettings.GodModeCooldown, () =>
            {
                _playersWithGodMode.Remove(userID);
                if (_playersWithGodMode.Count == 0)
                {
                    Unsubscribe(nameof(OnEntityTakeDamage));
                }

                if (playerData.Notification && player != null)
                {
                    Print(player.IPlayer, Lang("GodModeEnded", player.UserIDString));
                }
            });
        }

        private string CheckPlayer(BasePlayer player)
        {
            if (player.isMounted)
            {
                return "MapNoteTeleportMounted";
            }

            if (!player.IsAlive())
            {
                return "MapNoteTeleportDead";
            }

            return null;
        }

        private void OnMapMarkerAdded(BasePlayer player, MapNote note)
        {
            if (player == null || note == null || _playersOnCooldown.Contains(player.userID))
            {
                return;
            }

            if (_configData.GlobalSettings.UsePermission && !permission.UserHasPermission(player.UserIDString, PermissionUse))
            {
                if (!_configData.GlobalSettings.AdminsAllowed || !player.IsAdmin)
                {
                    return;
                }
            }

            var playerData = GetPlayerData(player.userID);
            if (!playerData.Enabled)
            {
                return;
            }

            TeleportToNote(player, note);
        }

        static float GetGroundPosition(Vector3 pos)
        {
            float y = TerrainMeta.HeightMap.GetHeight(pos);
            RaycastHit hitInfo;

            if (Physics.Raycast(
                new Vector3(pos.x, pos.y + 200f, pos.z),
                Vector3.down,
                out hitInfo,
                float.MaxValue,
                (Rust.Layers.Mask.Vehicle_Large | Rust.Layers.Solid | Rust.Layers.Mask.Water)))
            {
                var cargoShip = hitInfo.GetEntity() as CargoShip;
                if (cargoShip != null)
                {
                    return hitInfo.point.y;
                }

                return Mathf.Max(hitInfo.point.y, y);
            }

            return y;
        }

        private object OnEntityTakeDamage(BasePlayer player, HitInfo info)
        {
            if (player == null || !player.userID.IsSteamId())
            {
                return null;
            }

            if (_playersWithGodMode.Contains(player.userID))
            {
                return true;
            }

            return null;
        }

        private void Print(IPlayer player, string message)
        {
            string text;
            if (string.IsNullOrEmpty(Lang("Prefix", player.Id)))
            {
                text = message;
            }
            else
            {
                text = Lang("Prefix", player.Id) + message;
            }
#if RUST
            (player.Object as BasePlayer).SendConsoleCommand ("chat.add", 2, _configData.ChatSettings.SteamIDIcon, text);
            return;
#endif
            player.Message(text);
        }

        #endregion Helpers
    }
}
using System;
using System.Collections.Generic;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("Teleport", "Orf1", "1.0.1")]
    [Description("Lets players with permission teleport to any specified position.")]
    class Teleport : CovalencePlugin
    {
        private void Init()
        {
            permission.RegisterPermission("teleport.use", this);
            LoadDefaultMessages();
        }
        [Command("teleport")]
        private void SetCommand(IPlayer player, string command, string[] args)
        {
            if (player.HasPermission("teleport.use"))
            {
                if (args.Length == 3)
                {
                    try
                    {
                        float x = Int32.Parse(args[0]);
                        float y = Int32.Parse(args[1]);
                        float z = Int32.Parse(args[2]);
                        
                        var newPos = new GenericPosition(x, y, z);
                        player.Teleport(newPos);

                        string message = lang.GetMessage("Success", this, player.Id);
                        player.Message(message);
                    }
                    catch (FormatException)
                    {
                        string message = lang.GetMessage("InvalidUsage", this, player.Id);
                        player.Message(message);
                    }
                }
                else
                {
                    string message = lang.GetMessage("InvalidUsage", this, player.Id);
                    player.Message(message);
                }
            }
            else
            {
                string message = lang.GetMessage("NoPermission", this, player.Id);
                player.Message(message);
            }
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["Success"] = "You have teleported successfully.",
                ["NoPermission"] = "You do not have permission to use this command!",
                ["InvalidUsage"] = "Invalid usage. /teleport [x] [y] [z]"
            }, this);
        }
    }
}
using UnityEngine;
using System.Collections.Generic;

namespace Oxide.Plugins
{
    [Info("HW Fly", "klauz24", "1.2.4"), Description("Allows players with permissions to fly around.")]
    internal class HWFly : HurtworldPlugin
    {
        private Dictionary<string, float> _flying = new Dictionary<string, float>();

        private float _defaultFlySpeed = 75.0f;

        private string _perm = "hwfly.allowed";

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                {"Prefix", "<color=lightblue>[HW Fly]</color>"},
                {"NoPerm", "You got no permission to use this command."},
                {"Enabled", "Enabled."},
                {"Disabled", "Disabled."},
                {"Speed", "Fly speed set to {0}."}
            }, this);
        }

        [ChatCommand("fly")]
        private void FlyCommand(PlayerSession session, string command, string[] args)
        {
            if (session.IsAdmin || permission.UserHasPermission(GetID64(session), _perm))
            {
                if (args.Length == 0)
                {
                    if (_flying.ContainsKey(GetID64(session)))
                    {
                        _flying.Remove(GetID64(session));
                        hurt.SendChatMessage(session, GetLang(session, "Prefix"), GetLang(session, "Disabled"));
                    }
                    else
                    {
                        _flying.Add(GetID64(session), _defaultFlySpeed);
                        hurt.SendChatMessage(session, GetLang(session, "Prefix"), GetLang(session, "Enabled"));
                    }
                }
                if (args.Length >= 1)
                {
                    float speed;
                    if (float.TryParse(args[0], out speed))
                    {
                        if (_flying.ContainsKey(GetID64(session)))
                        {
                            _flying[GetID64(session)] = speed;
                            hurt.SendChatMessage(session, GetLang(session, "Prefix"), string.Format(GetLang(session, "Speed"), speed));
                        }
                        else
                        {
                            _flying.Add(GetID64(session), speed);
                            hurt.SendChatMessage(session, GetLang(session, "Prefix"), GetLang(session, "Enabled"));
                        }
                        hurt.SendChatMessage(session, GetLang(session, "Prefix"), string.Format(GetLang(session, "Speed"), speed));
                    }
                }
            }
            else
            {
                hurt.SendChatMessage(session, GetLang(session, "Prefix"), GetLang(session, "NoPerm"));
            }
        }

        private void Init() => permission.RegisterPermission(_perm, this);

        private object OnPlayerTakeDamage(PlayerSession session, EntityEffectSourceData source)
        {
            if (_flying.ContainsKey(GetID64(session)))
            {
                return 0f;
            }
            return null;
        }

        private void OnPlayerInput(PlayerSession session, InputControls input)
        {
            if (_flying.ContainsKey(GetID64(session)))
            {
                CharacterMotorSimple motor = session.WorldPlayerEntity.GetComponent<CharacterMotorSimple>();
                Vector3 direction = new Vector3(0f, 0f, 0f);
                float speed = _flying[GetID64(session)];
                if (input.Forward)
                {
                    direction = input.DirectionVector * speed;
                }
                if (input.Backward)
                {
                    direction = input.DirectionVector * -speed;
                }
                motor.IsGrounded = true;
                motor.Set_currentVelocity(direction.normalized * _flying[GetID64(session)]);
            }
        }

        private string GetID64(PlayerSession session) => session.SteamId.ToString();

        private string GetLang(PlayerSession session, string key) => lang.GetMessage(key, this, GetID64(session));
    }
}
using System;
using System.Reflection;
using System.Collections.Generic;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("FauxClip", "Colon Blow", "1.3.10")]
    class FauxClip : RustPlugin
    {
        public float GracefulLandingTime => Config.Get<float>("GracefulLandingTime");
        public float BaseNoClipSpeed => Config.Get<float>("BaseNoClipSpeed");
        public float SprintNoClipSpeed => Config.Get<float>("SprintNoClipSpeed");
        public float TurboNoClipSpeed => Config.Get<float>("TurboNoClipSpeed");
        public bool UseFauxClipGodMode => Config.Get<bool>("UseFauxClipGodMode");

        protected override void LoadDefaultConfig()
        {
            Config["GracefulLandingTime"] = 3;
            Config["BaseNoClipSpeed"] = .12;
            Config["SprintNoClipSpeed"] = .24;
            Config["TurboNoClipSpeed"] = 1;
            Config["UseFauxClipGodMode"] = true;

            SaveConfig();
        }

        class PlayerData
        {
            public BasePlayer player;
            public float speed;
            public Vector3 oldPos;
            public InputState input;
        }

        class LandingData
        {
            public BasePlayer player;
        }

        private readonly Dictionary<ulong, PlayerData> _noclip = new Dictionary<ulong, PlayerData>();
        private readonly Dictionary<ulong, LandingData> _landing = new Dictionary<ulong, LandingData>();
        private static readonly FieldInfo ServerInput = typeof(BasePlayer).GetField("serverInput", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        public static FieldInfo lastPositionValue;

        void Loaded()
        {
            permission.RegisterPermission("fauxclip.allowed", this);
            permission.RegisterPermission("fauxclip.norestriction", this);
            permission.RegisterPermission("fauxclip.canuseturbo", this);
            lastPositionValue = typeof(BasePlayer).GetField("lastPositionValue", (BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic));
        }

        void OnFrame()
        {
            if (_noclip.Count <= 0) return;

            foreach (var playerData in _noclip.Values)
            {
                var player = playerData.player;
                player.violationLevel = 0;
                if (NoBuild(player) & (NoAdmin(player) & (!IsAllowed(player, "fauxclip.norestriction"))))
                {
                    Restrictedairspace(player);
                    return;
                }

                if (player.net == null)
                {
                    Deactivatenoclip(player);
                    return;
                }

                var input = playerData.input;
                var newPos = playerData.oldPos;
                var currentRot = Quaternion.Euler(input.current.aimAngles);
                var speedMult = playerData.speed;

                if (input.IsDown(BUTTON.SPRINT))
                    speedMult = SprintNoClipSpeed;

                if (input.IsDown(BUTTON.USE) & (IsAllowed(player, "fauxclip.canuseturbo")))
                    speedMult = TurboNoClipSpeed;

                else if (input.IsDown(BUTTON.RELOAD))
                {
                    Deactivatenoclip(player);
                    return;
                }
                else if (input.IsDown(BUTTON.JUMP))
                {
                    newPos += (currentRot * Vector3.up * speedMult);
                }
                else if (input.IsDown(BUTTON.FORWARD))
                {
                    newPos += (currentRot * Vector3.forward * speedMult);
                }
                else if (input.IsDown(BUTTON.RIGHT))
                {
                    newPos += (currentRot * Vector3.right * speedMult);
                }
                else if (input.IsDown(BUTTON.LEFT))
                {
                    newPos += (currentRot * Vector3.left * speedMult);
                }
                else if (input.IsDown(BUTTON.BACKWARD))
                {
                    newPos += (currentRot * Vector3.back * speedMult);
                }
                else if (!input.IsDown(BUTTON.FORWARD))
                {
                    ForcePlayerPosition(player, newPos);
                }
                else
                    newPos = player.transform.position;

                if (newPos == playerData.oldPos) continue;

                player.PauseFlyHackDetection(5f);
                player.PauseSpeedHackDetection(5f);
                player.PauseVehicleNoClipDetection(5f);

                ForcePlayerPosition(player, newPos);
                playerData.oldPos = newPos;
            }
        }

        bool NoAdmin(BasePlayer player)
        {
            if (player.IsAdmin) return false;
            return true;
        }
        bool NoBuild(BasePlayer player)
        {
            if (player.CanBuild()) return false;
            return true;
        }

        void DamageOn(BasePlayer player)
        {
            player.metabolism.heartrate.min = 0;
            player.metabolism.heartrate.max = 1;
            player.metabolism.temperature.min = -100;
            player.metabolism.temperature.max = 100;
            player.metabolism.radiation_level.min = 0;
            player.metabolism.radiation_level.max = 100;
            player.metabolism.radiation_poison.min = 0;
            player.metabolism.radiation_poison.max = 500;
            player.metabolism.wetness.min = 0;
            player.metabolism.wetness.max = 1;
            player.metabolism.dirtyness.min = 0;
            player.metabolism.dirtyness.max = 100;
            player.metabolism.oxygen.min = 0;
            player.metabolism.oxygen.max = 1;
            player.metabolism.bleeding.min = 0;
            player.metabolism.bleeding.max = 1;
            player.metabolism.comfort.min = 0;
            player.metabolism.comfort.max = 1;
        }

        void DamageOff(BasePlayer player)
        {
            if (!UseFauxClipGodMode) return;

            foreach (var playerData in _noclip.Values)
            {
                player.metabolism.heartrate.min = 0.5f;
                player.metabolism.heartrate.max = 0.5f;
                player.metabolism.temperature.min = 32;
                player.metabolism.temperature.max = 32;
                player.metabolism.radiation_level.min = 0;
                player.metabolism.radiation_level.max = 0;
                player.metabolism.radiation_poison.max = 0;
                player.metabolism.wetness.min = 0;
                player.metabolism.wetness.max = 0;
                player.metabolism.dirtyness.min = 0;
                player.metabolism.dirtyness.max = 0;
                player.metabolism.oxygen.min = 1;
                player.metabolism.oxygen.max = 1;
                player.metabolism.bleeding.min = 0;
                player.metabolism.bleeding.max = 0;
                player.metabolism.comfort.min = 0;
                player.metabolism.comfort.max = 0;
                return;
            }
        }

        object OnEntityTakeDamage(BaseCombatEntity entity, HitInfo hitInfo)
        {
            if (!UseFauxClipGodMode) return null;

            if (UseFauxClipGodMode)
            {
                if (entity is BasePlayer)
                {
                    var player = (BasePlayer)entity;
                    if (_noclip.ContainsKey(player.userID))
                    {
                        return false;
                    }
                    if (_landing.ContainsKey(player.userID))
                    {
                        return false;
                    }
                }
            }
            return null;
        }

        void Deactivatenoclip(BasePlayer player)
        {
            _noclip.Remove(player.userID);
            SendReply(player, "NoClip Deactivated");
            _landing.Add(player.userID, new LandingData
            {
                player = player
            });
            LandingCycleDone(player);
        }

        void Restrictedairspace(BasePlayer player)
        {
            _noclip.Remove(player.userID);
            SendReply(player, "You cannot noclip while under 'Building Blocked' flag !");
            _landing.Add(player.userID, new LandingData
            {
                player = player
            });
            LandingCycleDone(player);
        }

        void Activatenoclip(BasePlayer player, float speed)
        {
            _noclip.Add(player.userID, new PlayerData
            {
                player = player,
                speed = speed,
                input = player.serverInput,
                oldPos = player.transform.position
            });
            SendReply(player, "NoClip Activated, press any key to start");
            DamageOff(player);
        }

        void Togglenoclip(BasePlayer player, float speed)
        {
            if (_noclip.ContainsKey(player.userID))
                Deactivatenoclip(player);
            if (_landing.ContainsKey(player.userID))
                SendReply(player, "Please Wait...");
            else
                Activatenoclip(player, speed);
        }

        void LandingCycleDone(BasePlayer player)
        {
            foreach (var playerData in _landing.Values)
            {
                timer.Once(GracefulLandingTime, () => _landing.Remove(player.userID));
                timer.Once(GracefulLandingTime, () => DamageOn(player));
            }
        }

        [ChatCommand("noclip")]
        void cmdChatnolcip(BasePlayer player, string command, string[] args)
        {
            if (!IsAllowed(player, "fauxclip.allowed"))
            {
                SendReply(player, "You are not worthy yet!");
                return;
            }

            var speed = BaseNoClipSpeed;
            if (args.Length > 0)
                speed = Convert.ToSingle(args[0]);
            Togglenoclip(player, speed);
        }

        void OnPlayerRespawned(BasePlayer player)
        {
            if (_noclip.ContainsKey(player.userID))
                _noclip.Remove(player.userID);
            if (_landing.ContainsKey(player.userID))
                _landing.Remove(player.userID);
        }

        void OnPlayerDisconnected(BasePlayer player, string reason)
        {
            if (_noclip.ContainsKey(player.userID))
                _noclip.Remove(player.userID);
            if (_landing.ContainsKey(player.userID))
                _landing.Remove(player.userID);
        }

        bool IsAllowed(BasePlayer player, string perm) => permission.UserHasPermission(player.UserIDString, perm);
    }
}
using Network;
using Facepunch;
using System;
using UnityEngine;
using Newtonsoft.Json;
using System.Collections;
using System.Collections.Generic;
using Oxide.Core.Plugins;
using Oxide.Core.Libraries.Covalence;

namespace Oxide.Plugins
{
    [Info("FauxAdmin", "Colon Blow", "2.0.0")]
    [Description("FauxAdmin")]

    public class FauxAdmin : CovalencePlugin
    {
        // Complete rewrite of plugin
        // Remember, player must disconnect and reconnect for Fauxadmins perms to take effect if they are logged in when granted.
        // And player must disconnect and reconnect if given god mode perms while logged in as well to take effect.
        // added a env.time command for fauxadmins to use if they have perms (not default)
        // and lots more. 
        // 6.12.23 update - added command for chat /noclip 

        #region Loadup

        private const string permAllowed = "fauxadmin.allowed"; //Grants player the FauxAdmin powers, that player must disconnect and reconnect to take effect.
        private const string permBypass = "fauxadmin.bypass"; //Allows specified FauxAdmin and (Blocked)Admins/Mods to noclip thru Non Auth TC's if config is enabled to Disable Globally.
        private const string permBlocked = "fauxadmin.blocked"; //Blocks specifed Real Admin or Mod from using a few commands. ie..Noclip..etc.
        private const string permGodMode = "fauxadmin.allowgod"; //Allows specified FauxAdmin, Admin or Mod to Use of GodMode, even if its Disabled Globally in config.
        private const string permGodBlock = "fauxadmin.blockgod"; //Blocks specified FauxAdmin, Admin or Mod to Use of GodMode, even if its Enabled Globally in config.
        private const string permAllowTime = "fauxadmin.allowtime"; //Allows specified FauxAdmin, Admin or Mod to Use of Env.Time commands, even if its not enabled Globally in config.
        private const string permAllowKill = "fauxadmin.allowkill"; //Allows specified FauxAdmin, Admin or Mod to Use of entkill command, even if its not enabled Globally in config.
        private const string permOnlyOwn = "fauxadmin.allowown"; //Allows Fauxadmin to only noclip ONLY under Authorized TC Zones.
        private const string permTerrain = "fauxadmin.allowterrain"; //Allows Fauxadmin to only noclip under Terrain if Disabled Globally in Config.
        private const string permCanLoot = "fauxadmin.canloot"; //Allows Fauxadmin to loot things when Disabled Globally in Config

        private void Loaded()
        {
            Unsubscribe(nameof(OnStructureDemolish));
            Unsubscribe(nameof(OnStructureRotate));
            Unsubscribe(nameof(OnStructureUpgrade));
            Unsubscribe(nameof(OnUserPermissionGranted));
            Unsubscribe(nameof(OnUserPermissionRevoked));
            Unsubscribe(nameof(CanLootEntity));
            permission.RegisterPermission(permAllowed, this);
            permission.RegisterPermission(permBypass, this);
            permission.RegisterPermission(permBlocked, this);
            permission.RegisterPermission(permGodMode, this);
            permission.RegisterPermission(permGodBlock, this);
            permission.RegisterPermission(permAllowTime, this);
            permission.RegisterPermission(permAllowKill, this);
            permission.RegisterPermission(permOnlyOwn, this);
            permission.RegisterPermission(permTerrain, this);
            permission.RegisterPermission(permCanLoot, this);
            LoadConfig();
        }

        private void OnServerInitialized()
        {
            if (config.fauxAdminSettings.DisableFauxAdminDemolish) Subscribe(nameof(OnStructureDemolish));
            if (config.fauxAdminSettings.DisableFauxAdminRotate) Subscribe(nameof(OnStructureRotate));
            if (config.fauxAdminSettings.DisableFauxAdminUpgrade) Subscribe(nameof(OnStructureUpgrade));
            if (config.fauxAdminSettings.MessageOnFauxAdminGrant) Subscribe(nameof(OnUserPermissionGranted));
            if (config.fauxAdminSettings.KickOnFauxAdminRevoke) Subscribe(nameof(OnUserPermissionRevoked));
            if (config.fauxAdminSettings.DisableLooting) Subscribe(nameof(CanLootEntity));

            ServerMgr.Instance.StartCoroutine(ProcessFuaxAdminControls());
        }

        #endregion

        #region Configuration

        private static PluginConfig config;

        private class PluginConfig
        {
            public FauxAdminSettings fauxAdminSettings { get; set; }

            public class FauxAdminSettings
            {
                [JsonProperty(PropertyName = "GodMode - Disable God Mode use for all Standard FauxAdmins (except those with fauxadmin.allowgod perms) ? (users must disconnect/reconnect to take effect) ")] public bool DisableGodMode { get; set; }
                [JsonProperty(PropertyName = "GodMode - Message player to disconect/reconnect when fauxadmin.allowgod perms are granted and they are in game ? (users must disconnect/reconnect to take effect) ")] public bool MessageOnGodGrant { get; set; }
                [JsonProperty(PropertyName = "GodMode - Force Disconnect of player when fauxadmin.allowgod perms are revoked and they are in game ? (users must disconnect/reconnect to take effect) ")] public bool KickOnGodRevoke { get; set; }

                [JsonProperty(PropertyName = "Command - Env.Time - Enable Use of Env.Time Admin command to set in game time, for all FauxAdmins ? (default false) ")] public bool EnableEnvTime { get; set; }
                [JsonProperty(PropertyName = "Command - EntKill - Enable Simulated Use of Admin Command (ent kill) for all FauxAdmins ? (default true)  ")] public bool EnableEntKill { get; set; }
                [JsonProperty(PropertyName = "Command - EntKill - Only Allow FauxAdmins to entkill there OWN stuff (default true) ? ")] public bool EntKillOnlyOwn { get; set; }

                [JsonProperty(PropertyName = "Noclip - Disallow FauxAdmins (unless they have the 'fauxadmin.bypass' permission) from using the Noclip (flying) feature in Tool Cupboard (TC) zones where they are not authorized, which are typically owned by other players. ")] public bool DisableNoclipOnNoBuild { get; set; }
                [JsonProperty(PropertyName = "Noclip - Allow the FauxAdmins to use the Noclip (flying) feature exclusively within Authorized Tool Cupboard (TC) Zones, thereby preventing them from flying in all other areas. ? ")] public bool EnableNoclipOnBuild { get; set; }

                [JsonProperty(PropertyName = "Antihack - Terrain Kill - Allow FauxAdmin to Fly underground without Antihack killing them (if disabled, FauxAdmin must have allowterrain perm or Godmode to fly underground) ?")] public bool EnableUnderGround { get; set; }
                [JsonProperty(PropertyName = "Looting - Disable FauxAdmin ability to loot things (boxes, containers, corpses..etc) ?")] public bool DisableLooting { get; set; }

                [JsonProperty(PropertyName = "Contruction - Disable FauxAdmin Ability to Demolish OTHER players building parts ? ")] public bool DisableFauxAdminDemolish { get; set; }
                [JsonProperty(PropertyName = "Contruction - Disable FauxAdmin Ability to Rotate OTHER players building parts ? ")] public bool DisableFauxAdminRotate { get; set; }
                [JsonProperty(PropertyName = "Contruction - Disable FauxAdmin Ability to Upgrade OTHER players building parts ? ")] public bool DisableFauxAdminUpgrade { get; set; }

                [JsonProperty(PropertyName = "Permissions - Grant - Message Online Player when Fauxadmin.allowed perms are granted (perms only take effect when disconnect/connect) ? ")] public bool MessageOnFauxAdminGrant { get; set; }
                [JsonProperty(PropertyName = "Permissions - Revoke - Disconnect Online Player when Fauxadmin.allowed perms are revoked (perms only take effect when disconnect/connect) ?")] public bool KickOnFauxAdminRevoke { get; set; }
                [JsonProperty(PropertyName = "Player Flag - Backend - Use (isAdmin) Instead of (isDeveloper) for FauxAdmin magic (default is dev, better compability with other plugins) ? ")] public bool UseAdminFlag { get; set; }
            }

            public static PluginConfig DefaultConfig() => new PluginConfig()
            {
                fauxAdminSettings = new PluginConfig.FauxAdminSettings
                {
                    DisableGodMode = false,
                    MessageOnGodGrant = true,
                    KickOnGodRevoke = true,
                    EnableEnvTime = false,
                    EnableEntKill = true,
                    EntKillOnlyOwn = true,
                    DisableNoclipOnNoBuild = true,
                    EnableNoclipOnBuild = false,
                    EnableUnderGround = true,
                    DisableLooting = false,
                    DisableFauxAdminDemolish = true,
                    DisableFauxAdminRotate = true,
                    DisableFauxAdminUpgrade = true,
                    UseAdminFlag = false,
                    MessageOnFauxAdminGrant = true,
                    KickOnFauxAdminRevoke = true,
                }
            };
        }

        protected override void LoadDefaultConfig()
        {
            PrintWarning("New configuration file created!!");
            config = PluginConfig.DefaultConfig();
        }
        protected override void LoadConfig()
        {
            base.LoadConfig();
            config = Config.ReadObject<PluginConfig>();
            SaveConfig();
        }
        protected override void SaveConfig()
        {
            Config.WriteObject(config);
        }

        #endregion

        #region Localization

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["notauthorized"] = "You are not authorized to use that command !!",
                ["disablegod"] = "You are not authorized to use God Mode !!",
                ["disablenoclip"] = "You are not allowed to noclip into a area you do not have TC priv.",
                ["processonconnect"] = "was processed as a FauxAdmin when they connceted.",
                ["processonload"] = "was processed as a FauxAdmin when plugin reloaded.",
                ["permgranted"] = "You have been granted Faux Admin, you must disconnect and reconnect to take effect.",
                ["permrevoked"] = "Faux Admin rights removed, You where disconnected.",
                ["godgranted"] = "You have been granted Admin God Mode, you must disconnect and reconnect to take effect.",
                ["godrevoked"] = "God Mode rights Removed, You where disconnected.",
            }, this);
        }

        #endregion

        #region Commands

        [Command("fly")]
        private void cmdfly(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            ConsoleNetwork.SendClientCommand(player.net.connection, "noclip");
        }

        [Command("noclip")]
        private void cmdNoClip(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            ConsoleNetwork.SendClientCommand(player.net.connection, "noclip");
        }

        [Command("entkill")]
        private void cmdEntKill(IPlayer iplayer, string command, string[] args)
        {
            var player = iplayer.Object as BasePlayer;
            if (player == null) return;

            // Must be a Standard Fauxadmin to continue checking
            if (!player.IPlayer.HasPermission(permAllowed)) return;

            if (config.fauxAdminSettings.EnableEntKill || player.IPlayer.HasPermission(permAllowKill))
            {
                EntKillProcess(player);
            }
            else player.IPlayer.Message(lang.GetMessage("notauthorized", this, player.IPlayer.Id));
        }

        #endregion

        #region Hooks

        private object OnClientCommand(Connection connection, string command)
        {
            //Puts("Debug1 : " + command);

            var player = BasePlayer.FindByID(connection.userid);
            if (player == null) return null;

            if (!player.IPlayer.HasPermission(permAllowed)) return null;

            if (command.Contains("setinfo \"global.god\" \"True\""))
            {
                if (!player.IPlayer.HasPermission(permGodMode))
                {
                    player.IPlayer.Message(lang.GetMessage("disablegod", this, player.IPlayer.Id));
                    return false;
                }
            }
            else if (command.Contains("env.time"))
            {
                if (config.fauxAdminSettings.EnableEnvTime || player.IPlayer.HasPermission(permAllowTime))
                {
                    string[] array = command.Split(' ');

                    if (array.Length > 1)
                    {
                        this.covalence.Server.Command("env.time " + array[1].ToString());
                        Puts($"{player} used the env.time command");
                    }
                    else
                    {
                        player.IPlayer.Message("Current Time is : " + TOD_Sky.Instance.Cycle.Hour.ToString());
                    }
                }
                else
                {
                    player.IPlayer.Message(lang.GetMessage("notauthorized", this, player.IPlayer.Id));
                }
            }

            return null;
        }

        private object CanLootEntity(BasePlayer player, BaseEntity container)
        {
            if (container is DroppedItemContainer || container is LootableCorpse || container is ResourceContainer || container is StorageContainer)
            {
                if (player.IPlayer.HasPermission(permAllowed) && !player.IPlayer.HasPermission(permCanLoot)) return true;
            }
            return null;
        }


        private void OnPlayerConnected(BasePlayer player)
        {
            ProcessPlayer(player);
        }

        private object CanUpdateSign(BasePlayer player, Signage sign)
        {
            if (player.IPlayer.HasPermission(permAllowed) && sign.OwnerID != player.userID)
            {
                return false;
            }
            return null;
        }

        private object OnStructureDemolish(BuildingBlock block, BasePlayer player)
        {
            if (player.IPlayer.HasPermission(permAllowed) && block.OwnerID.IsSteamId() && block.OwnerID != player.userID) return true;
            return null;
        }

        private object OnStructureRotate(BuildingBlock block, BasePlayer player)
        {
            if (player.IPlayer.HasPermission(permAllowed) && block.OwnerID.IsSteamId() && block.OwnerID != player.userID) return true;
            return null;
        }

        private object OnStructureUpgrade(BuildingBlock block, BasePlayer player)
        {
            if (player.IPlayer.HasPermission(permAllowed) && block.OwnerID.IsSteamId() && block.OwnerID != player.userID) return true;
            return null;
        }

        private void OnUserPermissionGranted(string id, string permName)
        {
            ulong playerid = Convert.ToUInt64(id);
            var player = BasePlayer.FindByID(playerid);
            if (player == null) return;
            if (config.fauxAdminSettings.MessageOnFauxAdminGrant && permName == permAllowed) player.IPlayer.Message(lang.GetMessage("permgranted", this, player.IPlayer.Id));
            if (config.fauxAdminSettings.MessageOnGodGrant && permName == permGodMode) player.IPlayer.Message(lang.GetMessage("godgranted", this, player.IPlayer.Id));
        }

        private void OnUserPermissionRevoked(string id, string permName)
        {
            ulong playerid = Convert.ToUInt64(id);
            var player = BasePlayer.FindByID(playerid);
            if (player == null) return;
            if (config.fauxAdminSettings.KickOnFauxAdminRevoke && permName == permAllowed) player.Kick(lang.GetMessage("permrevoked", this, player.IPlayer.Id));
            if (config.fauxAdminSettings.KickOnGodRevoke && permName == permGodMode) player.Kick(lang.GetMessage("godrevoked", this, player.IPlayer.Id));
        }

        private object OnPlayerViolation(BasePlayer player, AntiHackType type, float amount)
        {
            if (type == AntiHackType.FlyHack)
            {
                if (player.IPlayer.HasPermission(permAllowed)) return false;
            }
            if (type == AntiHackType.InsideTerrain)
            {
                if (config.fauxAdminSettings.EnableUnderGround) return false;
                if (player.IPlayer.HasPermission(permTerrain)) return false;
            }
            return null;
        }

        private void Unload()
        {
            DestroyAll<FauxAdminControl>();
        }

        #endregion

        #region Methods

        private void EntKillProcess(BasePlayer player)
        {
            RaycastHit RayHit;
            if (Physics.Raycast(player.eyes.HeadRay(), out RayHit, 10f, LayerMask.GetMask("Construction", "Deployed", "Default", "AI", "Player (Server)")))
            {
                var baseEntity = RayHit.GetEntity();
                if (baseEntity == null) return;
                if (baseEntity is BasePlayer || baseEntity.IsNpc) return;
                if (config.fauxAdminSettings.EntKillOnlyOwn && player.userID != baseEntity.OwnerID) return;
                baseEntity.Kill(BaseNetworkable.DestroyMode.Gib);
            }
        }

        private IEnumerator ProcessFuaxAdminControls()
        {
            foreach (var player in BasePlayer.activePlayerList)
            {
                var authLevel = player.net?.connection?.authLevel;
                if (authLevel != null && authLevel > 0 && !player.IPlayer.HasPermission(permBlocked)) continue;

                var hasAllowedPermission = player.IPlayer.HasPermission(permAllowed);
                var hasBypassPermission = player.IPlayer.HasPermission(permBypass);
                var hasGodBlockPermission = player.IPlayer.HasPermission(permGodBlock);
                var hasGodModePermission = player.IPlayer.HasPermission(permGodMode);

                if (hasAllowedPermission)
                {
                    if (!hasBypassPermission)
                    {
                        var controls = player.GetComponent<FauxAdminControl>();
                        if (!controls)
                        {
                            player.gameObject.AddComponent<FauxAdminControl>();
                            Puts($"{player} " + lang.GetMessage("processonload", this, player.IPlayer.Id));
                        }
                    }
                    if (hasGodBlockPermission || (config.fauxAdminSettings.DisableGodMode && !hasGodModePermission))
                    {
                        ConsoleNetwork.SendClientCommand(player.net.connection, "setinfo \"global.god\" \"False\"");
                        Puts($"{player} " + lang.GetMessage("processonload", this, player.IPlayer.Id));
                    }
                }
                yield return new WaitForEndOfFrame();
            }
        }


        private void ProcessPlayer(BasePlayer player)
        {
            if (player.net?.connection?.authLevel > 0)
            {
                if (player.IPlayer.HasPermission(permBlocked))
                {
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, false);
                    player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                    if (player.IPlayer.HasPermission(permGodBlock) || (config.fauxAdminSettings.DisableGodMode && !player.IPlayer.HasPermission(permGodMode)))
                    {
                        ConsoleNetwork.SendClientCommand(player.net.connection, "setinfo \"global.god\" \"False\"");
                    }
                }
            }
            else if (!player.IPlayer.HasPermission(permAllowed))
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, false);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, false);
            }
            else
            {
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, config.fauxAdminSettings.UseAdminFlag);
                player.SetPlayerFlag(BasePlayer.PlayerFlags.IsDeveloper, !config.fauxAdminSettings.UseAdminFlag);
                if (player.IPlayer.HasPermission(permGodBlock) || (config.fauxAdminSettings.DisableGodMode && !player.IPlayer.HasPermission(permGodMode)))
                {
                    ConsoleNetwork.SendClientCommand(player.net.connection, "setinfo \"global.god\" \"False\"");
                }
                if (!player.IPlayer.HasPermission(permBypass))
                {
                    var hasControls = player.GetComponent<FauxAdminControl>();
                    if (hasControls) hasControls.OnDestroy();
                    var addControls = player.gameObject.AddComponent<FauxAdminControl>();
                }
            }
            Puts($"{player} " + lang.GetMessage("processonconnect", this, player.IPlayer.Id));
        }


        private static void DestroyAll<T>()
        {
            var objects = GameObject.FindObjectsOfType(typeof(T));
            if (objects != null)
                foreach (var gameObj in objects)
                    GameObject.Destroy(gameObj);
        }

        #endregion

        #region FauxAdmin Control

        private class FauxAdminControl : FacepunchBehaviour
        {
            FauxAdmin instance = new FauxAdmin();
            private BasePlayer player;
            private bool hasFrozenPosition;

            private void Awake()
            {
                player = GetComponent<BasePlayer>();
                if (player == null) { OnDestroy(); return; }
                hasFrozenPosition = false;
            }

            private void DeactivateNoClip(BasePlayer player)
            {
                if (hasFrozenPosition) return;
                if (player.IPlayer.HasPermission(permBypass)) return;
                hasFrozenPosition = true;
                ServerMgr.Instance.StartCoroutine(DeactivateAndFreeze());
            }

            private IEnumerator DeactivateAndFreeze()
            {
                GenericPosition pos = player.IPlayer.Position();

                ConsoleNetwork.SendClientCommand(player.net.connection, "noclip");
                player.IPlayer.Message(instance.lang.GetMessage("disablenoclip", instance, player.IPlayer.Id));

                // Repeatedly teleport the player to the same position
                for (int i = 0; i < 8; i++)
                {
                    yield return new WaitForSeconds(0.1f);
                    player.IPlayer.Teleport(pos.X, pos.Y, pos.Z);
                }

                yield return new WaitForSeconds(0.1f);
                hasFrozenPosition = false;
            }


            private bool PlayerIsInOwnTCRange()
            {
                List<BuildingPrivlidge> privList = Pool.GetList<BuildingPrivlidge>();

                Vis.Entities<BuildingPrivlidge>(player.transform.position, 50f, privList);

                foreach (BuildingPrivlidge foundEnt in privList)
                {
                    if (foundEnt.IsAuthed(player))
                    {
                        Pool.FreeList<BuildingPrivlidge>(ref privList);
                        return true;
                    }
                }

                Pool.FreeList<BuildingPrivlidge>(ref privList);
                return false;
            }


            private void FixedUpdate()
            {
                if (player == null) { Destroy(gameObject); return; }

                if (player.IsFlying && !hasFrozenPosition)
                {
                    if (config.fauxAdminSettings.EnableNoclipOnBuild || player.IPlayer.HasPermission(permOnlyOwn))
                    {
                        if (!PlayerIsInOwnTCRange()) DeactivateNoClip(player);
                    }
                    else if (config.fauxAdminSettings.DisableNoclipOnNoBuild)
                    {
                        if (player.IsBuildingBlocked()) DeactivateNoClip(player);
                    }
                }
            }


            public void OnDestroy()
            {
                GameObject.Destroy(this);
            }
        }

        #endregion
    }
}
//NOPL
using Oxide.Core;
using System.Collections.Generic;
using UnityEngine;

namespace Oxide.Plugins
{
    [Info("Noclip Plugin", "AmericanSnipe", "1.0.0")]
    [Description("Allows players with permissions to toggle noclip mode.")]

    class NoclipPlugin : RustPlugin
    {
        private Dictionary<ulong, bool> noclipEnabled = new Dictionary<ulong, bool>();

        void Loaded()
        {
            permission.RegisterPermission("noclipplugin.use", this);
        }

        [ChatCommand("noclip")]
        private void ToggleNoclip(BasePlayer player)
        {
            if (!permission.UserHasPermission(player.UserIDString, "noclipplugin.use"))
            {
                SendReply(player, "You don't have permission to use this command.");
                return;
            }

            if (noclipEnabled.ContainsKey(player.userID))
            {
                noclipEnabled[player.userID] = !noclipEnabled[player.userID];
            }
            else
            {
                noclipEnabled.Add(player.userID, true);
            }

            player.SendConsoleCommand("noclip");

            SendReply(player, noclipEnabled[player.userID] ? "Noclip mode enabled." : "Noclip mode disabled.");
        }
    }
}
using System;
using System.Collections.Generic;

using CodeHatch.Common;
using CodeHatch.Engine.Behaviours;
using CodeHatch.Engine.Networking;
using CodeHatch.TerrainAPI;
using CodeHatch.UserInterface.Dialogues;

using Oxide.Core.Libraries.Covalence;

using UnityEngine;

namespace Oxide.Plugins
{
    [Info("3D Teleporter", "GeniusPlayUnique", "2.0.0")]
    [Description("A three dimentional teleporter.")] /**(© GeniusPlayUnique)*/
    class Teleporter : ReignOfKingsPlugin
    {
        readonly static string license = ""
            + "License Agreement for (the) 'Teleporter.cs' [ReignOfKingsPlugin]: "
            + "With uploading this plugin to umod.org the rights holder (GeniusPlayUnique) grants the user the right to download and for usage of this plugin. "
            + "However these rights do NOT include the right to (re-)upload this plugin nor any modified version of it to umod.org or any other webside or to distribute it further in any way without written permission of the rights holder. "
            + "It is explicity allowed to modify this plugin at any time for personal usage ONLY. "
            + "If a modification should be made available for all users, please contact GeniusPlayUnique (rights holder) via umod.org to discuss the matter and the terms under which to gain permission to do so. "
            + "By changing 'Accept License Agreement' below to 'true' you accept this License Agreement.";
        static bool LicenseAgreementAccepted;

        protected override void LoadDefaultConfig()
        {
            Config["EULA", "License", "License Agreement"] = license;
            Config["EULA", "License Acceptance", "Accept License Agreement"] = new bool();
        }

        protected override void LoadDefaultMessages()
        {
            lang.RegisterMessages(new Dictionary<string, string>
            {
                ["LicenseAgreementError"] = "Before using the [i]Teleporter.cs[/i] - plugin you need to accept the 'License Agreement' in the config-file.",
                ["TargetPlayerNotFound"] = "Unable to find target player with the name '{0}'.",
                ["OnlineTargetPlayerNotFound"] = "Unable to find player online with the name '{0}'.",
                ["UnableToTeleport"] = "Unable to teleport.",
                ["HeightWarningTitle"] = "[FF0000][i][u]Height Warning[/u]:[/i][FFFFFF]",
                ["HeightWarningSolidStructureText"] = "You are trying to teleport into a solid structure at the target coordinates. \n\n\n Resume teleportation process?",
                ["HeightWarningTerrainText"] = "You are trying to teleport {0}m below the calculated terrain height at the target coordinates. \n\n\n Resume teleportation process?",
                ["Confirm"] = "Confirm",
                ["Cancel"] = "Cancel",
                ["TeleportLog"] = "{0} teleported {1} to x: {2} y: {3} z: {4}."
            }, this, "en");
        }

        void Init()
        {
            if (!Config["EULA", "License", "License Agreement"].Equals(license))
            {
                LoadDefaultConfig();
            }

            LoadConfig();
            LicenseAgreementAccepted = Convert.ToBoolean(Config["EULA", "License Acceptance", "Accept License Agreement"]);

            permission.RegisterPermission("3D.teleport", this);
        }

        [ChatCommand("tpdelay")]
        void GetCoordinatesAndDelay(Player player, string command, string[] args)
        {
            if (!LicenseAgreementAccepted)
            {
                player.SendError(lang.GetMessage("LicenseAgreementError", this, player.Id.ToString()));
                return;
            }

            IPlayer iPlayer = covalence.Players.FindPlayerById(player.Id.ToString());

            if (!player.HasPermission("rok.teleport") && !iPlayer.HasPermission("3D.teleport")) return;

            LockTargetCoordinates(player, command, args);
        }

        [ChatCommand("tp")]
        void LockTargetCoordinates(Player player, string command, string[] args)
        {
            if (!LicenseAgreementAccepted)
            {
                player.SendError(lang.GetMessage("LicenseAgreementError", this, player.Id.ToString()));
                return;
            }

            IPlayer iPlayer = covalence.Players.FindPlayerById(player.Id.ToString());

            if (!player.HasPermission("rok.teleport") && !iPlayer.HasPermission("3D.teleport")) return;

            float f = 0;
            float x = 0;
            float y = 0;
            float z = 0;
            float delay = 0;

            if(args.Length == 0)
            {
                if (command.ToLower().Equals("tpdelay"))
                {
                    player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                    return;
                }

                x = 0;
                z = 0;

                y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                {
                    y--;
                }

                while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                {
                    y++;
                }

                Teleport(player, iPlayer, x, y, z);
            }
            else if (args.Length == 1)
            {
                if (command.ToLower().Equals("tpdelay"))
                {
                    if (float.TryParse(args[args.Length - 1], out f))
                    {
                        float.TryParse(args[args.Length - 1], out delay);

                        if (delay <= 0)
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }
                    }
                    else
                    {
                        player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                        return;
                    }

                    x = 0;
                    z = 0;

                    y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y;

                    while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                    {
                        y--;
                    }

                    while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                    {
                        y++;
                    }

                    float xNew = player.Entity.Position.x;
                    float yNew = player.Entity.Position.y;
                    float zNew = player.Entity.Position.z;

                    timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                    Teleport(player, iPlayer, x, y, z);
                    return;
                }

                try
                {
                    Player targetPlayer = Server.GetPlayerByName(args[0]);

                    x = targetPlayer.Entity.Position.x;
                    y = targetPlayer.Entity.Position.y;
                    z = targetPlayer.Entity.Position.z;
                }
                catch (Exception)
                {
                    player.SendError(string.Format(lang.GetMessage("TargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                    return;
                }

                GetBestPointAndTeleport(player, iPlayer, x, y, z);
            }
            else if (args.Length == 2)
            {
                if (float.TryParse(args[0], out f) && float.TryParse(args[1], out f))
                {
                    float.TryParse(args[0], out x);
                    float.TryParse(args[1], out z);

                    y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                    while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                    {
                        y--;
                    }

                    while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                    {
                        y++;
                    }

                    Teleport(player, iPlayer, x, y, z);
                }
                else
                {
                    Player targetPlayerOne;

                    try
                    {
                        targetPlayerOne = Server.GetPlayerByName(args[0]);
                        iPlayer = covalence.Players.FindPlayerById(targetPlayerOne.Id.ToString());
                    }
                    catch (Exception)
                    {
                        player.SendError(string.Format(lang.GetMessage("OnlineTargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                        return;
                    }

                    if (command.ToLower().Equals("tpdelay"))
                    {
                        iPlayer = covalence.Players.FindPlayerById(player.Id.ToString());

                        if (float.TryParse(args[args.Length - 1], out f))
                        {
                            float.TryParse(args[args.Length - 1], out delay);

                            if (delay < 0)
                            {
                                player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                                return;
                            }

                            x = targetPlayerOne.Entity.Position.x;
                            y = targetPlayerOne.Entity.Position.y;
                            z = targetPlayerOne.Entity.Position.z;

                            float xNew = player.Entity.Position.x;
                            float yNew = player.Entity.Position.y;
                            float zNew = player.Entity.Position.z;

                            timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                            GetBestPointAndTeleport(player, iPlayer, x, y, z);
                        }
                        else
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }
                    }
                    else
                    {
                        try
                        {
                            Player targetPlayerTwo = Server.GetPlayerByName(args[1]);

                            x = targetPlayerTwo.Entity.Position.x;
                            y = targetPlayerTwo.Entity.Position.y;
                            z = targetPlayerTwo.Entity.Position.z;
                        }
                        catch (Exception)
                        {
                            player.SendError(string.Format(lang.GetMessage("TargetPlayerNotFound", this, player.Id.ToString()), args[1]));
                            return;
                        }
                    }

                    GetBestPointAndTeleport(player, iPlayer, x, y, z);
                }
            }
            else if (args.Length == 3)
            {
                if (float.TryParse(args[0], out f) && float.TryParse(args[1], out f) && float.TryParse(args[2], out f))
                {
                    if (command.ToLower().Equals("tpdelay"))
                    {
                        float.TryParse(args[args.Length - 1], out delay);

                        if (delay <= 0)
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }

                        float.TryParse(args[0], out x);
                        float.TryParse(args[1], out z);

                        y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                        while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                        {
                            y--;
                        }

                        while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                        {
                            y++;
                        }

                        float xNew = player.Entity.Position.x;
                        float yNew = player.Entity.Position.y;
                        float zNew = player.Entity.Position.z;

                        timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                        Teleport(player, iPlayer, x, y, z);
                    }
                    else
                    {
                        float.TryParse(args[0], out x);
                        float.TryParse(args[1], out y);
                        float.TryParse(args[2], out z);

                        Vector3 targetVector = new Vector3(x, z);

                        if (TeleportUtil.IsPointBlocked(new Vector3(x, y, z), 0.5f) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z), 0.5f))
                        {
                            if ((y - TerrainAPIBase.GetTerrainHeightAt(targetVector)) <= 0)
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), string.Format(lang.GetMessage("HeightWarningTerrainText", this, player.Id.ToString()), (Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(targetVector))).ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, 0, 0, 0, 0, options, dialogue, data));
                            }
                            else
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), lang.GetMessage("HeightWarningSolidStructureText", this, player.Id.ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, 0, 0, 0, 0, options, dialogue, data));
                            }
                        }
                        else
                        {
                            Teleport(player, iPlayer, x, y, z);
                        }
                    }
                }
                else if (float.TryParse(args[1], out f) && float.TryParse(args[2], out f))
                {
                    try
                    {
                        Player targetPlayer = Server.GetPlayerByName(args[0]);
                        iPlayer = covalence.Players.FindPlayerById(targetPlayer.Id.ToString());
                    }
                    catch (Exception)
                    {
                        player.SendError(string.Format(lang.GetMessage("OnlineTargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                        return;
                    }

                    float.TryParse(args[1], out x);
                    float.TryParse(args[2], out z);

                    y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y;

                    while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                    {
                        y--;
                    }

                    while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                    {
                        y++;
                    }

                    Teleport(player, iPlayer, x, y, z);
                }
                else if (float.TryParse(args[args.Length - 1], out f))
                {
                    if (command.ToLower().Equals("tpdelay"))
                    {
                        float.TryParse(args[args.Length - 1], out delay);

                        if (delay <= 0)
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }

                        Player targetPlayerOne;

                        try
                        {
                            targetPlayerOne = Server.GetPlayerByName(args[0]);
                            iPlayer = covalence.Players.FindPlayerById(targetPlayerOne.Id.ToString());
                        }
                        catch (Exception)
                        {
                            player.SendError(string.Format(lang.GetMessage("OnlineTargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                            return;
                        }

                        try
                        {
                            Player targetPlayerTwo = Server.GetPlayerByName(args[1]);

                            x = targetPlayerTwo.Entity.Position.x;
                            y = targetPlayerTwo.Entity.Position.y;
                            z = targetPlayerTwo.Entity.Position.z;
                        }
                        catch (Exception)
                        {
                            player.SendError(string.Format(lang.GetMessage("TargetPlayerNotFound", this, player.Id.ToString()), args[1]));
                            return;
                        }

                        float xNew = targetPlayerOne.Entity.Position.x;
                        float yNew = targetPlayerOne.Entity.Position.y;
                        float zNew = targetPlayerOne.Entity.Position.z;

                        timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                        GetBestPointAndTeleport(player, iPlayer, x, y, z);
                    }
                    else
                    {
                        player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                        return;
                    }
                }
                else
                {
                    player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                    return;
                }
            }
            else if (args.Length == 4)
            {
                if (float.TryParse(args[0], out f) && float.TryParse(args[1], out f) && float.TryParse(args[2], out f) && float.TryParse(args[3], out f))
                {
                    if (command.ToLower().Equals("tpdelay"))
                    {
                        float.TryParse(args[args.Length - 1], out delay);

                        if (delay <= 0)
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }

                        float.TryParse(args[0], out x);
                        float.TryParse(args[1], out y);
                        float.TryParse(args[2], out z);

                        float xNew = player.Entity.Position.x;
                        float yNew = player.Entity.Position.y;
                        float zNew = player.Entity.Position.z;

                        Vector3 targetVector = new Vector3(x, z);

                        if (TeleportUtil.IsPointBlocked(new Vector3(x, y, z), 0.5f) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z), 0.5f))
                        {
                            if ((y - TerrainAPIBase.GetTerrainHeightAt(targetVector)) <= 0)
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), string.Format(lang.GetMessage("HeightWarningTerrainText", this, player.Id.ToString()), (Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(targetVector))).ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, xNew, yNew, zNew, delay, options, dialogue, data));
                            }
                            else
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), lang.GetMessage("HeightWarningSolidStructureText", this, player.Id.ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, delay, xNew, yNew, zNew, options, dialogue, data));
                            }
                        }
                        else
                        {
                            timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                            Teleport(player, iPlayer, x, y, z);
                        }
                    }
                }
                else if (float.TryParse(args[1], out f) && float.TryParse(args[2], out f) && float.TryParse(args[3], out f))
                {
                    if (command.ToLower().Equals("tpdelay"))
                    {
                        float.TryParse(args[args.Length - 1], out delay);

                        if (delay <= 0)
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }

                        Player targetPlayer;

                        try
                        {
                            targetPlayer = Server.GetPlayerByName(args[0]);
                            iPlayer = covalence.Players.FindPlayerById(targetPlayer.Id.ToString());
                        }
                        catch (Exception)
                        {
                            player.SendError(string.Format(lang.GetMessage("OnlineTargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                            return;
                        }

                        float.TryParse(args[1], out x);
                        float.TryParse(args[2], out z);

                        y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                        while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                        {
                            y--;
                        }

                        while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                        {
                            y++;
                        }

                        float xNew = targetPlayer.Entity.Position.x;
                        float yNew = targetPlayer.Entity.Position.y;
                        float zNew = targetPlayer.Entity.Position.z;

                        timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                        Teleport(player, iPlayer, x, y, z);
                    }
                    else
                    {
                        try
                        {
                            Player targetPlayer = Server.GetPlayerByName(args[0]);
                            iPlayer = covalence.Players.FindPlayerById(targetPlayer.Id.ToString());
                        }
                        catch (Exception)
                        {
                            player.SendError(string.Format(lang.GetMessage("OnlineTargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                            return;
                        }

                        float.TryParse(args[1], out x);
                        float.TryParse(args[2], out y);
                        float.TryParse(args[3], out z);

                        Vector3 targetVector = new Vector3(x, z);

                        if (TeleportUtil.IsPointBlocked(new Vector3(x, y, z), 0.5f) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z), 0.5f))
                        {
                            if ((y - TerrainAPIBase.GetTerrainHeightAt(targetVector)) <= 0)
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), string.Format(lang.GetMessage("HeightWarningTerrainText", this, player.Id.ToString()), (Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(targetVector))).ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, 0, 0, 0, 0, options, dialogue, data));
                            }
                            else
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), lang.GetMessage("HeightWarningSolidStructureText", this, player.Id.ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, 0, 0, 0, 0, options, dialogue, data));
                            }
                        }
                        else
                        {
                            Teleport(player, iPlayer, x, y, z);
                        }
                    }
                }
                else
                {
                    player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                }
            }
            else if (args.Length == 5)
            {
                if (float.TryParse(args[1], out f) && float.TryParse(args[2], out f) && float.TryParse(args[3], out f) && float.TryParse(args[4], out f))
                {
                    if (command.ToLower().Equals("tpdelay"))
                    {
                        float.TryParse(args[args.Length - 1], out delay);

                        if (delay <= 0)
                        {
                            player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                            return;
                        }

                        Player targetPlayer;

                        try
                        {
                            targetPlayer = Server.GetPlayerByName(args[0]);
                            iPlayer = covalence.Players.FindPlayerById(targetPlayer.Id.ToString());
                        }
                        catch (Exception)
                        {
                            player.SendError(string.Format(lang.GetMessage("OnlineTargetPlayerNotFound", this, player.Id.ToString()), args[0]));
                            return;
                        }

                        float.TryParse(args[1], out x);
                        float.TryParse(args[2], out y);
                        float.TryParse(args[3], out z);

                        float xNew = targetPlayer.Entity.Position.x;
                        float yNew = targetPlayer.Entity.Position.y;
                        float zNew = targetPlayer.Entity.Position.z;

                        Vector3 targetVector = new Vector3(x, z);

                        if (TeleportUtil.IsPointBlocked(new Vector3(x, y, z), 0.5f) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z), 0.5f))
                        {
                            if ((y - TerrainAPIBase.GetTerrainHeightAt(targetVector)) <= 0)
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), string.Format(lang.GetMessage("HeightWarningTerrainText", this, player.Id.ToString()), (Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(targetVector))).ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, delay, xNew, yNew, zNew, options, dialogue, data));
                            }
                            else
                            {
                                player.ShowConfirmPopup(lang.GetMessage("HeightWarningTitle", this, player.Id.ToString()), lang.GetMessage("HeightWarningSolidStructureText", this, player.Id.ToString()), lang.GetMessage("Confirm", this, player.Id.ToString()), lang.GetMessage("Cancel", this, player.Id.ToString()), (options, dialogue, data) => HeightWarning(player, iPlayer, command, x, y, z, delay, xNew, yNew, zNew, options, dialogue, data));
                            }
                        }
                        else
                        {
                            timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));

                            Teleport(player, iPlayer, x, y, z);
                        }
                    }
                    else
                    {
                        player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                    }
                }
                else
                {
                    player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
                }
            }
            else
            {
                player.SendError(lang.GetMessage("UnableToTeleport", this, player.Id.ToString()));
            }
        }

        void GetBestPointAndTeleport(Player player, IPlayer iPlayer, float x, float y, float z)
        {
            double ii = Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(new Vector3((x + 1), (z + 1))));
            double id = Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(new Vector3((x + 1), (z - 1))));
            double di = Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(new Vector3((x - 1), (z + 1))));
            double dd = Math.Abs(y - TerrainAPIBase.GetTerrainHeightAt(new Vector3((x - 1), (z - 1))));

            double Iii;
            double Iid;
            double Idi;
            double Idd;

            double Dii;
            double Did;
            double Ddi;
            double Ddd;

            float newY = y;

            while (TeleportUtil.IsPointBlocked(new Vector3((x + 1), newY, (z + 1))) || TeleportUtil.IsPointBlocked(new Vector3((x + 1), (newY + 1), (z + 1))))
            {
                newY++;
            }

            Iii = Math.Abs(y - newY);

            newY = y;

            while (TeleportUtil.IsPointBlocked(new Vector3((x + 1), newY, (z - 1))) || TeleportUtil.IsPointBlocked(new Vector3((x + 1), (newY + 1), (z - 1))))
            {
                newY++;
            }

            Iid = Math.Abs(y - newY);

            newY = y;

            while (TeleportUtil.IsPointBlocked(new Vector3((x - 1), newY, (z + 1))) || TeleportUtil.IsPointBlocked(new Vector3((x - 1), (newY + 1), (z + 1))))
            {
                newY++;
            }

            Idi = Math.Abs(y - newY);

            newY = y;

            while (TeleportUtil.IsPointBlocked(new Vector3((x - 1), newY, (z - 1))) || TeleportUtil.IsPointBlocked(new Vector3((x - 1), (newY + 1), (z - 1))))
            {
                newY++;
            }

            Idd = Math.Abs(y - newY);

            newY = y;

            while (!TeleportUtil.IsPointBlocked(new Vector3((x + 1), (newY - 1), (z + 1))))
            {
                newY--;
            }

            Dii = Math.Abs(y - newY);

            newY = y;

            while (!TeleportUtil.IsPointBlocked(new Vector3((x + 1), (newY - 1), (z - 1))))
            {
                newY--;
            }

            Did = Math.Abs(y - newY);

            newY = y;

            while (!TeleportUtil.IsPointBlocked(new Vector3((x - 1), (newY - 1), (z + 1))))
            {
                newY--;
            }

            Ddi = Math.Abs(y - newY);

            newY = y;

            while (!TeleportUtil.IsPointBlocked(new Vector3((x - 1), (newY - 1), (z - 1))))
            {
                newY--;
            }

            Ddd = Math.Abs(y - newY);

            if (Iii >= Dii)
            {
                ii = Iii;
            }
            else
            {
                ii = Dii;
            }

            if (Iid >= Did)
            {
                id = Iid;
            }
            else
            {
                id = Did;
            }

            if (Idi >= Ddi)
            {
                di = Idi;
            }
            else
            {
                di = Ddi;
            }

            if (Idd >= Ddd)
            {
                dd = Idd;
            }
            else
            {
                dd = Ddd;
            }

            if (ii <= id && ii <= di && ii <= dd)
            {
                x++;
                z++;

                y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                {
                    y--;
                }

                while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                {
                    y++;
                }
            }
            else if (id <= ii && id <= di && id <= dd)
            {
                x++;
                z--;

                y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                {
                    y--;
                }

                while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                {
                    y++;
                }
            }
            else if (di <= ii && id <= di && di <= dd)
            {
                x--;
                z++;

                y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                {
                    y--;
                }

                while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                {
                    y++;
                }
            }
            else if (dd <= ii && dd <= id && dd <= di)
            {
                x--;
                z--;

                y = TerrainAPIExtensions.GetTerrainSurfaceCoordinate(new Vector2(x, z)).y + 1000;

                while (!TeleportUtil.IsPointBlocked(new Vector3(x, (y - 1), z)))
                {
                    y--;
                }

                while (TeleportUtil.IsPointBlocked(new Vector3(x, y, z)) || TeleportUtil.IsPointBlocked(new Vector3(x, (y + 1), z)))
                {
                    y++;
                }
            }

            Teleport(player, iPlayer, x, y, z);
        }

        void HeightWarning(Player player, IPlayer iPlayer, string command, float x, float y, float z, float delay, float xNew, float yNew, float zNew, Options options, Dialogue dialogue, object data)
        {
            if (options.Equals(Options.Cancel) || options.Equals(Options.No))
            {
                return;
            }
            else
            {
                if (command.ToLower().Equals("tpdelay"))
                {
                    timer.Once(delay, () => Teleport(player, iPlayer, xNew, yNew, zNew));
                }

                Teleport(player, iPlayer, x, y, z);
            }
        }

        void Teleport(Player player, IPlayer iPlayer, float x, float y, float z)
        {
            iPlayer.Teleport(x, y, z);

            Puts(string.Format(lang.GetMessage("TeleportLog", this), player.Name, iPlayer.Name, x.ToString(), y.ToString(), z.ToString()));
        }
    }
}
